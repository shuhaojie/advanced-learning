# 常见问题

## 一、 Django

### 1. Django请求的生命周期？

请求 -> nginx服务器 -> 分析资源类型，静态请求直接返回响应，动态请求分发给uwsgi(网关) -> uwsgi找到Django框架 -> 中间件判断请求是否合法 ->
到达路由urls -> 路由将请求交给视图函数 -> 视图函数处理请求并作出响应

### 2. wsgi是什么？

web服务器和Python web应用程序之间要通信，需要借助到WSGI。web服务器在将请求转交给web应用程序之前，需要先将http报文转换为WSGI规定的格式。

### 3. wsgi和asgi的区别？

- 相同：wsgi和asgi都是网关接口，用于web服务器和web应用程序之间的通信接口。

- 不同：wsgi是基于HTTP协议的，不支持websocket。asgi是在wsgi上的扩展，既支持HTTP协议，又websocket协议。

### 4. FBV和CBV区别？

FBV：基于函数的视图 CBV：基于类的视图，更推荐使用CBV。原因：

- 提高代码复用性
- 不同的函数(get, post等)针对不同的HTTP方法(GET, POST)处理，提高代码可读性

### 5. csrf攻击是什么? Django的csrf token实现机制？

csrf攻击：跨域攻击利用某些网站只验证cookie，但是不验证是否是用户发送请求，而导致的攻击。例如用户先访问受信任网站A，再访问危险网站B。B网站通过
用户点击链接或者图片，发送危险请求给A网站，由于网站A将cookie给到用户了，此时网站A不知道是用户点击还是跨域攻击。

- django第一次响应客户端请求时，服务端生成一个token并把token保存在SESSION;同时, 服务端把token放到cookie中返给前端。
- 下次前端需要发起请的时候把这个token值加入到请求头中，一起传给后端：Cookies:{csrftoken:xxxxx}
- 后端校验前端请求带过来的token和SESSION里的token是否一致

### 6. cookie, session, token, jwt, Oauth2

#### (1) cookie和session的区别?

- 相同: cookie和session都是为了知道客户身份而产生的。
- 不同: cookie存储在客户端; session存储在服务端。

> 注意，不一定需要用户登录才知道用户身份。也可以使用其他方式来确定用户身份，例如IP地址等，只是这种方式没有用户登录好。

#### (2) cookie和session如何配合?

用户第一次请求的时候，服务器根据相关信息，创建对应的session，将此session的SessionID返回给浏览器，浏览器将其存到Cookie中。

用户第二次请求的时候，浏览器会携带cookie，服务端从cookie中获取SessionID，再根据SessionID查找对应的Session信息。

#### (3) session和token的区别?

- token无需存储在服务端，服务端对签发给用户的token进行解密来判断用户的身份。和
- session相比，相当于时间换空间。
- token的扩展性好，因为如果是集群部署，它不必像session那样，去从当前服务器找session信息。

#### (4) jwt的信息可以被解密到? 如何保证安全?

需要注意的是，jwt只能用来验证是否被篡改，而不能验证是否被冒充。保护token是用户的责任。

jwt的payload内容是可以被解密的，但是由于密钥的存在，是可以判断jwt是否被篡改了。

#### (5) 如何判断一个jwt是否过期?

在生成payload的时候，需要在payload中添加过期时间exp字段。解密的时候，用exp和当前时间比较，如果exp大于当前时间，表明已经过期。

#### (6)OAuth2是什么?

登录一个非受信任网站，网站要求输入账号、密码，但是用户不愿意把密码交给此网站。此时可以非受信任网站可以要求用户给予授权，获取授权后向受信任网站获
取令牌，获取令牌后，向资源服务器申请资源。

### 7. Django中间的作用，有哪些自带的中间件？

中间件可以在请求到达视图之前或响应离开视图之后对请求和响应进行修改或处理，以实现一些通用的功能。例如：

* 认证和授权：中间件可以检查请求中的用户信息，验证用户是否有访问权限。
* 缓存：中间件可以缓存请求和响应，以提高应用程序的性能。
* 日志记录：中间件可以记录请求和响应的详细信息，以便于调试和排错。
* 跨站点请求伪造防护(CSRF)：中间件可以检查请求中的CSRF令牌，确保请求来自于合法的来源。
* 通过使用中间件，可以将这些通用的功能从业务逻辑中分离出来，提高代码的可维护性和复用性。

### 8. 说一下Django的架构模式？

- M 表示模型(Model)：编写程序应有的功能，负责业务对象与数据库的映射(ORM)。
- T 表示模板(Template)：负责如何把页面(html)展示给用户。
- V 表示视图(View)：负责业务逻辑，并在适当时候调用Model和Template。

### 9. Django的ORM机制？

- Django类: 数据库表
- Django类属性: 表中的字段
- Django具体某个对象: 表中的一条数据

### 10. Django的queryset有哪些特性?

* 惰性：`user_obj = User.objects.filter(id=1)`，这个语句并不会直接执行sql，而是会等后面`user_obj`的时候再真正执行sql
* 自带缓存：上述sql执行完之后，会将user_obj数据存在缓存中，下次用的时候直接读缓存

### 11. select_related和prefetch_related的区别？

- select_related: 当有外键时，一次性获得所有(子表和父表)数据，只执行一次SQL查询。
```python
from django.db import models
class Province(models.Model):
    name = models.CharField(max_length=10)

class City(models.Model):
    name = models.CharField(max_length=5, primary_key=True)
    province = models.ForeignKey(Province, on_delete=models.CASCADE)
c = City.objects.select_related('province').first()
print(c.province.name)
```
- prefetch_related: 分别查询每个表，然后根据它们之间的关系进行处理，执行两次SQL查询。

### 12. django 事务作用?

`transaction.atomic()`: 保证对数据库一连串的操作，要么成功要么失败。

### 13. select_for_update作用?

添加行锁，保证更新的字段在事务范围内被锁住。一般要和`transaction.atomic()`配合使用。
```python
from django.db import transaction

entries = Entry.objects.select_for_update().filter(author=request.user)
with transaction.atomic():
    for entry in entries:
        ...
```

### 14. F和Q的作用？

* F: 操作表中的某个字段，F()允许Django在未实际连接数据的情况下具有对数据库字段值的引用，例如`Book.objects.update(price=F("price")+20)`
* Q: 对对象进行复杂查询，并支持`and, or, not`操作符

### 15. blank和null的区别？

- blank: 允许表单为空
- null: 允许字段为空

### 16. django路由系统中name的作用？

用于反向解析路由,相当于给url取个别名，只要这个名字不变，即使对应的url改变，通过该名字也能找到该条url

### 17. 什么是restful？

restful是一种软件设计风格，并不是标准，restful有很多规范。简而言之，restful要具备三点:

- 看url就知道要什么。例如获取某人的好友列表:`http://api.qc.com/v1/friends`

- 看http method就知道干什么。`POST http://api.qc.com/v1/friends` 添加好友(在request body指定好友id)

- 看http status code就知道结果如何。比如最常用的`200`表示成功，`500`表示Server内部错误等。

### 18. Django如何使用缓存?

首先需要在`settings`中设置`CACHE`配置选项

- 全站缓存：添加中间件即可实现整站缓存。适用于静态网站。

```python
MIDDLEWARE = [
    'django.middleware.cache.UpdateCacheMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.cache.FetchFromCacheMiddleware',
]
```

- 视图缓存: `@cache_page`装饰器(有一个过期时间的必填参数)，适合内容不怎么变化的页面。例如个人博客，可能一天只更新一篇。

## 二、 FastAPI

### 1. 谈一下FastAPI框架和Django的区别?

Django是一个成熟的框架，提供了ORM，模板引擎，身份认证等功能，同时Django有比较成熟的社区支持，有比较广泛的第三方资源(例如drf等)。

FastAPI是一个高性能框架，它提供了类型检查，异步编程等特性，此外FastAPI自带swagger文档，非常方便进行前后端对接。

### 2. 对async/await的理解?

- async: 一个函数如果加上async，就是一个协程对象，调用的时候不会去执行函数体内的东西，需要将其放在事件循环(loop)内执行
- await: IO等待，在IO等待期间，如果事件循环列表内有其他任务，会切换去执行其他任务。如果事件循环列表内没有任务，执行当前任务。

## 三、 消息队列和Celery

### 1. 请解释Celery的工作流程?

celery通过消息进行通信，启动一个任务，任务模块(celery beat)向中间件(broker)发送一条消息，然后broker将消息传递给一个worker，由worker执行broker分配的任务。

### 2. Celery使用哪种消息中间件？

官方推荐的消息中间件是Redis和RabbitMQ，其中Redis既可以作为broker，又可以作为backend

* Redis: 适合快速传递小消息。大消息可能使系统堵塞。
* RabbitMQ: RabbitMQ比Redis更好地处理更大的消息。但是如果许多消息很快进入，应该考虑Redis。

### 3. 如何在应用程序中使用Celery发布任务？

可以使用`delay`或则`apply_async`方法发送任务消息，二者没有区别。`delay`方法是`apply_async`方法的简化版，不支持执行选项，只能传递任务的参数。

### 4. 如何调度任务?如何跟踪任务状态?

* 通过`apply_async`来调度任务，例如让任务定时执行`YourTask.apply_async(args=[some, args, here], eta=when)`

* 可以通过`AsyncResult`来查看任务状态：`AsyncResult(task.request.id).state`
    * `PENDING`: 任务等待被执行
    * `STARTED`: 任务已经开始
    * `SUCCESS`: 任务成功执行
    * `FAILURE`: 任务执行失败
    * `RETRY`: 正在重试任务
    * `REVOKED`: 任务被撤销

### 5. celery如何确保任务不丢失(被完整执行)？

* 如果工作程序在执行过程中崩溃，当需要再次执行任务时，可以设置参数`CELERY_ACKS_LATE=True`，它会在程序执行完之后再给celery发消息。

注意:
> 1. celery默认是当任务被消费者接收后，会向消息队列发送确认消息，告诉消息队列任务已经被接收。
> 2. `CELERY_ACKS_LATE=True`的缺点是等到任务完成的确认信号可能需要花很长时间，增加了系统的时间成本。此外，一个测试正常的任务在执行过程中也
     不会出现情况，因此不需要等待确认信号才认为任务完成。

* 对于某些**可能会执行失败的代码块**，使用try/except，在except中执行celery的retry方法。例如做预测时可能会产生OOM，此时可以对该代码用retry 的方案。

* 消息持久化：Celery创建的任务默认是持久化到磁盘中的，即使在消息队列服务异常或者宕机的情况下，任务也不会丢失。

### 6. Celery有哪些常见的性能问题？如何解决这些问题？

* 队列积压：例如每30秒往队列里发任务。可以使用`kombu`来设置最大消息数，多余的消息将被丢弃。
* 内存泄漏：执行完task之后没有及时释放内存。可以设置`CELERYD_TASK_TIME_LIMIT`参数，任务到时会释放内存。

### 7. 什么是消息队列？

消息队列，简称MQ(Message Queue)，它其实就指消息中间件。生产者 -> 消息队列(中间件) -> 消费者。

消息队列本质就是个转发器，包含接收消息、存消息、消费消息的过程。

### 8. 消息队列应用场景？

* 应用解耦：例如下单扣库存，订单系统需要调用库存系统，两系统存在耦合关系。如果库存系统无法访问，此时调用会失败。可以引入消息队列解决，用户下单后，
  订单系统将消息写入到消息队列，并返回下单成功。库存系统订阅订单系统，获取下单信息，进行相关操作。
* 流量削峰：例如12306，每秒可以处理2k请求，高峰期5k请求进来，可以将请求写入到消息队列，12306可以每秒从消息队列中取2k个请求来处理。高峰过后，积 压的请求慢慢处理。另外，如果消息队列长度超过设定的阈值，可以抛弃用户请求。
* 异步：例如用户注册成功后，需要给用户发短信和发邮件，这两个操作都可以做成异步的。

### 9. 消息队列如何解决消息丢失问题

- 生产端：开启事务，如果在发送消息时出现问题，可以回滚事务，保证消息不会丢失。

- 中间件：开启持久化，消息写入之后会持久化到磁盘。

- 消费端：关闭rabbitmq的自动ack，自己代码里确保处理完的时候，在程序里做ack。

### 10. 消息队列如何保证消息的顺序性？

例如binlog做数据库同步，三条日志log1/log2/log3发送给同一个queue，被三个消费者消费，可能消费者先消费完log2了

- 创建多个queue，每个消费者固定消费一个queue的消息。
- 单线程进行消费，多线程可能会出现错乱的问题

### 11. 消息队列有可能发生重复消费吗？如何幂等处理？

可能会发生重复消费：消息被成功消费后，消费者会发送一个成功标志给MQ，MQ收到这个标志就表示消息已经成功消费了，就不会再发送给其他消费者了。但是如果
因为网络这个标志没有送到MQ就丢失了，MQ就认为这个消息没有被成功消费，就会再次发送给其他消费者消费，就造成了重复。

> 幂等性: 重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响

幂等处理重复消息: 在消息中添加一个唯一标识，消费者在消费消息时，可以通过判断标识是否已经消费过该条消息，避免重复消费

### 12. 如何处理消息队列的消息积压问题？

消息积压原因只有两种：要么是发送变快了，要么是消费变慢了

- 增加消费者：可以通过增加消费者的数量来提高消息的消费速度，从而减少消息积压的情况。
- 增加消息队列的容量：如果消息队列的容量不足，可以考虑增加消息队列的容量，以容纳更多的消息。

## 四、 Redis

### 1. Redis优点?

Redis是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快

### 2. Redis可以用来干什么?

* 缓存: 这是Redis应用最广泛地方，基本所有的Web应用都会使用Redis作为缓存，来降低数据源压力，提高响应速度。
* 消息队列: 前面已经介绍过
* 分布式锁: 在单体应用中我们通过锁解决的是控制共享资源访问的问题，而分布式锁是解决了分布式系统中控制共享资源访问的问题。与单体应用不同的是，分布
式系统中竞争共享资源的最小粒度从线程升级成了进程。
```bash
加锁: setnx命令, 指令返回1时, 说明获得锁成功
解锁: del命令
超时时间: expire, 防止长时间不释放锁.
```

### 3. Redis和Memcached对比?

相同点：

- 都是基于内存的数据库，一般都用来当做缓存使用。
- 都有过期策略。

不同点：

- Redis支持的数据类型更丰富(String、Hash、List、Set、ZSet)，而Memcached只支持最简单的key-value数据类型
- Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可再次加载使用。Memcached没有持久化功能，数据全在内存中
- Redis原生支持集群模式，Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据

### 4. 为什么使用Redis作为MySQL的缓存?

- Redis具备高性能：访问MySQL中的数据这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在Redis中，下次再访问这些数据的时候就可以直
  接从缓存中获取了。MySQL中的对应数据改变的之后，同步改变Redis缓存中相应的数据即可。
- Redis具备高并发：单台设备的Redis的QPS(Query Per Second，每秒钟处理完请求的次数)是MySQL的10倍，Redis单机的QPS能轻松破10w，而MySQL单机 的QPS很难破1w。

### 5. Redis常见数据类型及使用场景?

- 字符串String: `set key value`
- 列表List: `LPUSH mylist "world"`, `LPUSH mylist "hello"`。`LRANGE mylist 0 -1`输出hello world。
- 哈希Hash: `HSET website google "www.google.com"`, `HSET website baidu "www.baidu.com"`。`HGET website google`输出
"www.google.com"。
- 集合Set:
- 有序集合Zset:

### 6. Redis是单线程还是多线程?

#### (1) Redis是单线程还是多线程?

既是单线程又是多线程

- 单线程: 对外提供键值存储服务的主要流程是单线程，接收客户端请求 -> 解析请求 -> 进行数据读写等操作 -> 发送数据给客户端。这个过程是由一个线程
  (主线程)来完成的。

- 多线程: Redis启动的时候会新增后台线程，用来AOF刷盘等操作。因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么很容易发生阻塞

#### (2) Redis对外为什么要设计成单线程的?

- redis是基于内存的，CPU不是Redis的瓶颈，内存的读写速度非常快；

> 多线程的出现主要为了解决IO设备的读写速度往往比CPU的处理速度慢造成的单线程程序运行阻塞问题

- redis是单线程的，省去了很多上下文切换线程的时间；

### 7. Redis如何持久化?

#### (1) 持久化方式

- AOF日志(Append Only File)：将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现
数据恢复了
- RDB快照(Redis Database)：在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；

#### (2) 优缺点

- AOF: 优点是丢失数据少，但是数据恢复不快(需要逐行执行命令)。
- RDB: 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。

## 五、 数据库

### 1. 事务

#### (1) 事务是什么? 

事务是一组操作的集合，是一个不可分割的工作单位，事务会把所有的操作整体提交给系统，这些操作要么同时成功，要么同时失败。

#### (2) 事务如何开启?

在MySQL中，事务是默认开启的`autocommit=ON`, **当执行一条DML语句，MySQL会隐式的提交事务，也就是说每一条DML语句都是在一个事务之内的**。

**当我们想把多条SQL语句包裹在一个事务中时**，可以使用如下的方式

```bash
begin; # 或者start transaction;
# DML语句
commit; # 或者rollback
```

此外，当设置`autocommit=OFF`时，开启事务的方式也是如同上面所示。

#### (3) 事务和锁之间的关系?

- 事务具有ACID(原子性、一致性、隔离性和持久性)，**锁是用于解决隔离性的一种机制**。
- **开启事务就自动加锁**，由于前面说过，执行一条DML语句，MySQL会隐式的提交事务。因此，**一个DML语句是自动开启事务，自动加锁的**

#### (4) 事务的四大特性?

事务特性ACID: 原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)。

- 原子性: 是指事务包含的所有操作要么全部成功，要么全部失败回滚。
- 一致性: 事务执行前后必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。
- 隔离性: 跟隔离级别相关，如read committed，一个事务只能读到已经提交的修改。
- 持久性: 是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

#### (5) 并发事务问题?

- 脏读: 是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
- 不可重复读: 一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。
- 幻读: 一个事务在查询数据时，没有对应记录，但是在插入时，发现数据已存在，就像产生幻觉一样。

#### (6) 事务的隔离级别?

四种隔离级别，越往下，越安全，但是效率越差。mysql默认的是`repeatable read`

- Read uncommitted (读未提交)：所有事务都可以看到其他未提交事务的执行结果。
- Read committed (读已提交)：一个事务只能看见已经提交事务所做的改变。解决脏读。
- Repeatable read (可重复读)：MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。解决不可重复读。
- Serializable (串行化)：通过强制事务排序，使之不可能相互冲突。解决幻读。

### 2. 锁

#### (1) 为什么需要锁?

数据和CPU、I/O、RAM一样，也是可以攻多用户共享的资源，保证数据并发访问时数据的一致性、有效性，需要用到锁。

#### (2) 锁的分类

按使用方式: 
- 共享锁(也叫读锁): 可以对表级锁和行级锁加共享锁
- 排他锁(也叫写锁): 可以对表级锁和行级锁加排他锁

按锁的粒度: 
- 全局锁: 对整个数据库进行加锁，一般用于数据库备份。
- 表级锁: 分为三种：表锁，元数据锁，意向锁。
  - 表锁: 
    - 表读锁：加锁后，所有客户端只能读，不能写。
    - 表写锁：加锁的客户端可读可写，其他客户端读写被阻塞，需要等加锁客户端是否后才能读、写。
  - 元数据锁: 表上有活动事务时，不可以对元数据(例如表结构)进行写入操作，避免DML语句和DDL语句的冲突。
  - 意向锁: 意向锁的目的是为了快速判断表里是否有记录被加锁。如果没有[意向锁]，那么加[独占表锁]时，需要遍历表里所有记录。
- 行级锁: 也分为三种：行锁，间隙锁，临键锁
  - 行锁：锁定单个行记录的锁，防止其他事务对此行进行update和delete
    - 读锁：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
    - 写锁：允许获得排它锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排它锁。
  - 间隙锁：锁定索引记录间隙
  - 临键锁：行锁和间隙锁的组合，同时锁住数据和数据的间隙。

按场景
- 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。
- 乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。
- 分布式锁
- 死锁

#### (3) 什么时候会自动加锁？

InnoDB**会自动给update，delete，insert行为先申请锁，申请到之后，才执行相关操作，最后再释放锁**。

#### (4) 什么时候需要手动加锁？

#### (5) 加锁需要放在事务中吗?

一个DML语句就是一个事务，

### 3. 索引

#### (1) 索引的作用？

数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，MySQL默 认的B+树索引高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。

#### (2) 什么情况下建索引?什么情况下不建索引?

建索引

- 经常用于查询的字段
- 经常需要排序的字段建立索引，因为索引已经排好序，可以加快排序查询速度

不建索引

- where条件中用不到的字段不适合建立索引
- 需要经常增删改的字段

#### (3) 索引分类

基本分类

- 主键索引: 唯一非空索引，不允许有空值。
- 唯一索引: 索引列中的值必须是唯一的，但是允许为空值。
- 组合索引: 多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用(最左匹配原则)
- 全文索引: 只有在MyISAM引擎上才能使用

根据存储形式

- 聚集索引: 数据存储与索引在一起，叶子节点保存的行数据。聚集索引必须有，并且只有一个。
- 二级索引: 数据与索引分开，叶子节点保存对应的主键

两种分类之间的关系

- 如果存在主键，主键就是聚集索引
- 如果不存在主键，会使用第一个唯一索引作为聚集索引
- 如果都不存在，InnoDB会生成rowid作为聚集索引

#### (4) 最左匹配原则

最左原则指的是如果SQL语句中用到了联合索引中的最左边的索引，那么这条SQL语句就可以利用这个联合索引去进行匹配。例如对(a,b)字段建立一个索引

- where a=1 √
- where a=1 and b=2 √
- where b=2 and a=1 √
- where b=2 ×

#### (5) 回表查询

当执行查询语句如select * from user where name='Arm', 它首先去找二级索引，将Arm的首字母和节点进行对比，然后定位到其对应的聚焦索引10，
再用聚焦索引10去找到其后面对应的数据块。这就是回表查询。

> 二级索引下面挂的是对应的id，聚集索引下面挂的是对应的数据。回表查询会查两次。

#### (6) 索引的数据结构

- B+树索引：所有元素都会出现在叶子节点中，上面的元素主要是起索引的作用。
- 哈希索引：基于哈希表实现的，存储引擎会对索引列进行哈希计算得到哈希码。将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值

#### (7) 为什么B+树比B树和哈希索引更适合做索引?

- 相比于B树索引：B树无论是叶子节点还是非叶子节点，都会保存数据，导致一页中存储的键值减少，指针跟着减少。B+树在非叶子节点不存放数据，可以存放的指针就多。
- 相比于哈希索引：它只支持等值匹配，不支持范围匹配

### 4. 运维

#### (1) binlog和redo log区别？

- binlog: 记录了所有DDL(数据定义语言)和DML(数据操作语言)。用于主从复制、灾难时数据恢复。
- redo log: 如果没有redo log的话，MySQL每次的update操作都要更新磁盘文件。InnoDB先将更新记录写到redo log中，并更新内存，空闲时再更新磁盘。

#### (2) 主从复制的作用？主从复制如何实现？

- 数据的备份：主库出现问题，可以快速切换到从库提供服务。
- 读写分离：降低主库的访问压力。增删改在主库，查询在从库。

实现方法：将主数据库的二进制日志传到从库服务器，在从库上对这些日志重新执行(重做)，使得从库和主库的数据保持同步。

#### (3) 读写分离的作用? 如何实现读写分离?

- 作用：读写分离将读和写分开，主数据库提供写操作，从数据库提供读操作。这样能有效减轻单台数据库的压力。
- 实现：应用程序直接来分别操作主数据和从数据库是比较麻烦的。可以通过MyCat来作为代理，应用程序将CRUD操作给到MyCat，MyCat根据具体语句，分别发 给主数据库或者从数据库。

#### (4) 分库分表的作用? 垂直拆分和水平拆分是怎么拆分的? 分库分表会带来哪些问题?

作用: 将数据分散存储，使得单一数据库/表的数据量变小，来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。

- 垂直分库：以表为依据，对系统中的不同业务进行拆分。例如将用户User库放到一个数据库服务器，将订单Order库放到另一个数据库服务器。
- 垂直分表：以字段为依据，根据字段属性进行拆分。例如将用户Student表的id, name, sex等常用字段放到一个数据库服务器，将id, junior_school字段 放到另一个服务器。
- 水平分库：以字段为依据，将一个数据库拆分到多个数据库。例如将User库和Order库2022年的数据放到一个服务器，将2023年的放到另外一个服务器。
- 水平分表：以字段为依据，将一个表拆分到多个表。例如将Student表2022年的数据放到一个服务器，将2023年的放到另外一个服务器。

> 一般垂直分库，水平分表

拆分之后应用程序可能需要访问多台服务器，操作比较繁琐，可以通过MyCat来作为代理来解决这个问题。

### 5. 优化

#### (1) MySQL优化

- 建表时选取合适的字段：
    * 例如邮政编码确定是6位数，可以用char(6)。建表时占用的空间越小越好。Django里面只有`CharField`。
    * 尽量设置字段为非空(not null)，执行查询的时候，数据库不用去比较null值

- SQL语句优化: 可以借助慢查询优化和explain执行语句，来进行定位。具体优化措施有：
    * 使用连接来代替子查询: 子查询时MYSQL需要创建临时表，查询完毕后再删除这些临时表，速度会慢。
    * 查询时尽量不用`select *`，原因有以下几点：

      (1)`select id from t where name='张三'`，不需要回表查询，但是如果`select *`则需要回表。增加IO操作，如果字段

      (2) 增加数据传输时间和网络开销

      (3) 增加IO操作，例如有一个字段是TEXT
- 增加索引: 对where语句后常用到的字段建立索引，例如study_instance_uid, patient_id
- 使用慢查询日志和explain执行计划来进行定位

#### (2) Django ORM优化方法

- 做查询的时候不要查询所有字段，而是查要用的字段，可以用`values_list`查询要用的字段
- 批量插入的时候，可以用`bulk_create`方法
- 涉及到外键查询时，可以用`select_related`, 这样可以只做一次查询。

### 6. 设计数据库要考虑哪些方面

- 数据库类型：关系型数据库还是非关系型数据库
- 数据库关系：
  - 确定表之间的关联关系，例如一对多，多对多。 
  - 是否需要建立视图
- 数据库性能：
  - 建立合适的索引。
  - 是否需要分表。
  - 是否需要主从。

### 7. MySQL和PostgreSQL区别?

* PostgreSQL支持json数据格式，MySQL不支持
* PostgreSQL支持DDL语句的回滚
* PostgreSQL默认隔离级别是读已提交，MySQL是不可重复读。

### 8. 视图

#### (1)视图的作用? 

假设我们要联合查询4张表中的20几个字段，那么这个select查询语句会非常复杂。但是这样的语句我们在很多地方都需要用到，如果将它编写成视图，那么使用
起来会方便很多。

#### (2) 视图数据是如何更新的?

如果要在视图上执行更新操作，请确保该视图使用`WITH CHECK OPTION`定义，并且该视图不包含复杂的查询。例如聚合函数，UNION，UNION ALL等。

## 六、 计算机网络

### 1. 三次握手

* 第一次握手：客户端-将SYN(synchronous, 建立联机)置1，随机产生初始序列号seq number，发送SYN和seq number给服务端，并进入SYN_SENT状态
* 第二次握手：服务端-收到客户端的SYN，将SYN置1，ACK置1，产生ack number(ack=seq+1)，发送ACK和ack number给客户端，并进入SYN_RCVD状态
* 第三次握手：客户端-检查ack number是否为seq number+1，ACK是否为1，确认无误将ACK置1，产生一个ack number=ack number(服务端)+1，发送给
  服务器；进入ESTABLISHED状态；服务器检查ACK为1和ack number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立

> SYN(synchronous 建立联机), ACK(acknowledgement 确认), Sequence number(顺序号码) Acknowledge number(确认号码)

三次握手是为了保证保证客户端和服务端都有收、发能力。就像线上面试：(1)面试官问可以听到吗 (2)我说可以听到，你那边可以听到吗 (3) 面试官说可以听到

### 2. 四次挥手

* 第一次挥手：客户端-将FIN置为1，发送一个序列号seq number给服务端；进入FIN_WAIT_1状态
* 第二次挥手：服务端-收到FIN之后，发送ACK=1，ack number=seq number+1给客户端；进入CLOSE_WAIT状态。此时客户端没有要发送的数据，但仍可接受服务器发来的数据。
* 第三次挥手：服务端-将FIN置1，发送FIN，seq number给客户端(对！服务端发两次！)；进入LAST_ACK状态；
* 第四次挥手：客户端-收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个ack number=seq number(服务端)+1给服务器；服务器收到后， 确认ack
  number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL(报文段最长寿命)时间后，也进入CLOSED状态。完成四次挥手。

> FIN(finish结束) RST(reset重置)

四次挥手保证客户端和服务端都发起结束并回应结束，才代表这次连接真正结束。就像结束面试一样：(1) 面试官说我没有其他问题了 (2)我说好的 (3)我想了 想我这边还有没有其他问题，确认好之后说我也没有其他问题了 (4) 面试官说好的

之所以挥手多一次，是因为面试官没有其他问题，我这边还有可能有其他问题。而在连接的时候，只需要去确认连接，不会有判断(自己是否还有其他问题)，因此服 务端收、发是在一起的。

### 3. TCP和UDP的区别

TCP

* 面向连接：发送数据之前需要建立连接
* 可靠传输：
    * 应答机制: 每个报文必须得到接受方的应答才认为报文传送成功。
    * 超时重传: 发送端发送报文后启动定时器，如果指定时间没有得到应答就重新发送报文
    * 错误校验: 发送数据时，同时发送校验码。接受方接受时先取数据，再通过校验函数来判断数据是否有误。
    * 流量控制: TCP协议还会通过流量控制的方式来避免发送过快导致接收方来不及接受的情况。
* TCP面向字节流

UDP

* 无连接：发送数据之前不需要建立连接
* 不可靠传输：接收方收到报文后，不需要给出任何确认
* UDP面向报文

### 4. TCP和HTTP的区别

Python用`socket`来发TCP请求，用`requests`来发HTTP请求。

* TCP: 传输层协议，保证传输安全
* HTTP：应用层协议，是构建在TCP协议之上的。HTTP协议是浏览器和web服务器之间的一种协议，是用来规定数据具体格式的(TCP协议没有格式)

### 5. HTTP和HTTPS区别

* 端口不同：HTTP使用的是80端口，HTTPS使用443端口；
* HTTP信息是明文传输，HTTPS则是具有安全性的ssl加密传输协议；
* HTTPS通信需要证书，一般需要向证书颁发机构(CA)购买

### 6. HTTP请求的GET和POST区别

* 用途：GET一般用于从服务器获取资源；而POST有可能改变服务器上的资源。
* 请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中。
* 安全性：GET请求可被浏览器缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中；POST的参数不会被保存，安全性相对较高；
* 请求长度：GET的长度有限制，而POST数据大小无限制

### 7. 输入网址到获得内容的过程

1. 浏览器输入网址
2. 浏览器查询DNS，完成域名解析，获得对应的IP
3. 获得IP后，向服务器请求建立连接，发起三次握手
4. TCP/IP连接建立起来后，浏览器向服务器发送HTTP请求
5. 服务器接收请求后，根据路径参数，映射到特定的请求处理器进行处理，将处理结果及相应的视图返回给浏览器
6. 浏览器解析并渲染视图，如果遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源
7. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面

### 8. HTTP常见状态码

* 2xx状态码：操作成功。200 OK
* 3xx状态码：重定向。301 永久重定向；302暂时重定向。
* 4xx状态码：客户端错误。400 请求出错(请求语法格式有误, 服务器无法理解)；401 未授权；403 禁止访问；404 找不到；
* 5xx状态码：服务端错误。500服务器内部错误；501服务不可用。

### 9. 网关是什么? 有啥作用?

所有网络都有一个边界，如果网络想要与边界之外的设备，节点或网络通信，则它们需要网关的功能。

在微服务中，会有一个微服务网关，是系统对外的唯一入口，客户端可以通过统一网关接入微服务。

## 七、docker

### 1. docker的优点?

- 快速部署: 可以通过如下步骤来快速部署
    * `docker save -o 压缩包 镜像名`
    * `docker load -i 压缩包`
    * 创建容器, 启动容器....
- 跨平台

### 2. docker镜像和docker容器的关系?

- docker镜像: 是docker容器的基础，它包括了应用程序及其依赖项等所有需要运行的组件
- docker容器: 是docker镜像的一个实例，可以运行在docker宿主机上

### 3. docker容器的生命周期?

- 创建: `docker create`
- 启动: `docker start`

> docker run = docker create + docker start

- 进入: `docker exec`
- 停止: `docker stop`
- 删除: `docker rm container_id`

### 4. 如何将本地文件复制到docker容器中? Dockerfile中如何复制文件?

本地文件可以通过如下方式复制到docker容器中: `docker cp localfile.txt container:/path/to/destination`

Dockerfile可以通过如下方式来复制文件

- COPY命令
- ADD命令
- RUN cp命令

另外还可以使用挂载的方式：docker run -v /data:/data -d nginx:latest

### 5. docker容器之间如何通信?

- 使用docker网络进行通信: 在同一个网络中的容器可以相互通信。具体方法如下
    * 创建网络：`docker network create -d bridge my-dnet`
    * 启动容器时指定网络: `docker run --network my-dnet my-image`
    * Dockerfile中可以通过`CMD ["--network", "my-network"]`来指定网络

### 6. docker容器和宿主机之间如何通信?

可以通过映射容器的端口到宿主机上，例如启动容器时`docker run -p 8080:80 --name test nginx`，这样就将宿主机8080端口和容器80端口进行了绑定， 访问宿主机的8080端口，就相当于访问容器的80端口

### 7. 简要说下docker的网桥模式?

网桥模式是docker默认的网络模式。当docker进程启动时，会在主机上创建一个名为`docker0`的虚拟网桥，此主机上启动的docker容器会连接到这个虚拟网桥上。
虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。

### 8. docker数据卷的作用？如何使用数据卷？

作用：

- 数据卷将主机上的目录或文件与容器内的目录或文件进行映射，使得容器内的数据可以被持久化保存并与主机上的数据进行同步
- 数据卷还可以用于多个容器之间共享数据，以及用于在容器之间共享配置文件等

使用：

- 创建数据卷：`docker create volume my-vol`，这一步相当于在宿主机上创建了一个目录
- 挂载数据卷：`docker run -d -v my-vol:/my-vol-test ac232364af84`

### 9. Dockerfile的作用是什么？如何用Dockerfile构建镜像?

Dockerfile是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。

构建镜像：`docker build -t runoob/ubuntu:v1 . `，这里的`.`表示的是Dockerfile的相对位置



###  10. Dockerfile中的cmd和docker-compose中的启动命令有何区别？

- Dockerfile:
- docker-compose:

### 11. docker-compose的作用是什么？它和docker run的区别?

docker-compose是用于定义和运行多容器docker的工具，可以通过YML文件来配置应用程序需要的所有服务。然后，使用一个命令`docker-compose up`，就 可以从yml文件配置中创建并启动所有服务。

- docker run 完全是基于命令行，而docker-compose可以从yaml文件中读配置信息
- docker run 一次只能启动一个容器，而docker-compose可以启动多个
- docker run启动一个容器后，再次用相同命令，会另外再启动一个容器。`docker-compose up`则不会，如果已经启动过，就不会再启动了。

### 12. docker容器和虚拟机的区别？

- 硬件资源利用不同：docker容器共享操作系统内核，占用资源相对较少，可以在同一主机上运行多个docker容器，这些不同的docker可以利用相同的资源，例 如磁盘、网络。而虚拟机则需要独立的操作系统和虚拟硬件，占用资源相对较多。
- 启动速度：启动一个docker几秒钟，虚拟机启动则需要数分钟。

## 八、Python

### 1. 多进程，多线程， GIL锁， 线程池

- 进程：操作系统进行资源分配的基本单位。进程面向的是操作系统。
- 线程：是程序执行的最小单位。线程面向的是CPU

- 并行：线程数少于核数
- 并发：单核多线程，需要不断切换线程

- 计算密集型：多进程。因为可以用多核。
- IO密集型：多线程。有阻塞时会自动切换到非阻塞的线程。

GIL锁：CPython解释器独有。每个线程在执行的时候必须获得GIL锁，因此Python的多线程并不是严格意义上的多线程。

线程池：线程池是一种池化的技术，类似的还有数据库连接池、HTTP连接池等。池化的思想主要是为了减少每次获取和结束资源的消耗，提高对资源的利用率。比如
在一些偏远地区打水不方便的，大家会每段时间把水打过来存在池子里，这样平时用的时候就直接来取就好了，不需要每次用的时候再去创建。

### 2. 锁

#### (1) 线程安全

多条线程访问的时候，程序按照预期执行，不会出现数据污染的情况。

典型的线程不安全案例: 开启两个线程对一个全局变量，一个线程执行一千万次+1操作，一个线程执行一千万次-1操作，可能会出现最后全局变量不为0的情况。因
为第一个线程可能在CPU中执行了500万次加法，此时还没来得及将数据写往内存，线程就被切换走了，此时另外一个线程拿到的全局变量还是0。

#### (2) 同步锁、递归锁、条件锁、事件锁

- 同步锁(互斥锁): `threading.Lock`，每次只能被一个线程使用，其他线程需等待锁的释放。可以用`lock.acquire()`和`lock.release()`来获取和释放锁，
也可以使用`with lock:`语句来完成获取和释放。加同步锁可能会让代码变成串行状态。
- 递归锁: `threading.RLock`，在同步锁的基础上可以做到连续重复使用多次`acquire()`。例如一个函数中需要用到锁，它调用一个函数也需要用到锁，此
时如果用同步锁就不行，用递归锁就可以。
- 条件锁: 
- 事件锁:

#### (3) 死锁

获得锁之后，没有释放锁(例如函数在if语句里直接return了，释放锁在return后)，导致其他线程苦苦等待锁的到来。

#### (4) 单线程和多线程加锁的区别？

- 单线程只有一个线程执行。
- 多线程加锁：多个线程同时运行，只是**同一时间只有一个线程能够访问共享资源**，其他部分不受影响。

### 3. Python内存管理和内存回收

- 在Python中，一切皆对象。
- 任何对象的创建，都会放到环状双向链表中。一个对象的创建，在c语言底层会存至少4个值：上一个对象，下一个对象，引用次数，类型。
- 当引用次数为0时，这个对象就是垃圾，就会被回收。
- 对于列表等数据类型，可能存在循环引用问题。Python通过标记清除机制来检查是否有循环引用，来解决循环引用问题。
- Python引入分代回收机制，**当0代中的变量达到700个时，会进行扫描**，如果引用次数为0，回收掉。如果不为0，进入1代。

> 一段代码中声明的变量，不会因为代码执行完，就被回收，而是要按照分代回收机制来进行回收。

### 4. list的底层实现

### 5. dict的底层实现

Python的dict是基于哈希表实现的

### 6. 元组和list的区别

元组tuple是不可变的，而列表是可变的。

### 7. set是如何实现唯一的

set也是基于哈希表，当往哈希表中添加元素时，Python会首先计算该元素的哈希值，如果存在则不添加，这样保证不重复。

### 8. 装饰器，生成器，迭代器

- 装饰器：是一个返回函数的高阶函数。在装饰器里面定义了一个wrapper函数，返回的也是这个wrapper函数。在调用时，只需要在函数上加上`@`符号即可，
执行的时候会先去执行装饰器，在执行函数体内的代码。
- 迭代器：迭代器可以像列表一样获取其中每个元素，但是和列表不同的是，它并没有一次性把所有的元素都加载到内存中，而是调用next方法时才返回该元素。
- 生成器：生成器本质也是一个迭代器。生成器在函数返回时不是用return，而是yield。yield对应的值不会立即返回，而是在调用next方法时才返回。

### 9. 浅拷贝和深拷贝的区别？

- 浅拷贝只复制了原始对象的引用，而没有复制对象本身，因此新对象和原始对象共享同一块内存。而深拷贝则是复制了对象本身，新对象和原始对象互不干扰。

- 对于不可变对象(例如字符串)，浅拷贝和深拷贝没有区别。因为不可变对象本身就无法被修改，所以共享和独立都没有任何问题。但对于可变对象(如列表、字 典等)，浅拷贝和深拷贝就有了明显的区别。

### 10. Python内建数据类型有哪些? 哪些是不可变的, 哪些是可变的?

- 数字类型(int、float、complex): 不可变
- 字符串类型(str): 不可变
- 布尔类型(bool): 不可变
- 元组类型(tuple): 不可变
- 列表类型(list): 可变
- 集合类型(set): 可变
- 字典类型(dict): 可变

### 11. Python单例

#### (1) 单例的作用？

- 方便控制：就像日志，如果多个人同时来写，你一笔我一笔肯定会乱。
- 节省资源：就像喝水，每个人都要喝水，但没有必要每人都打一口井。对应到计算机里，日志管理、打印机、数据库连接池、应用配置每必要创建多个。

#### (2) 如何实现一个单例？
```python
class Single(object):
    _instance = None

    def __new__(cls, *args, **kw):
        if cls._instance is None:
            cls._instance = object.__new__(cls)
        return cls._instance

    def __init__(self):
        pass
```

- `__new__`: 创建对象时会调用
- `__init__`: 对象创建好之后会调用

#### (3) 单例的使用场景

## 九、 数据结构

常见的数据结构有8种，其中4种是线性的，4种是非线性的。

### 1. 时间复杂度

* 常数阶O(1): 例如每天早上给直属领导打招呼。
* 线性阶O(n): 例如每天早上给组内所有同事打招呼。
* 对数阶O(log(n)): 猜同事的薪资，每次往中间猜。
* 线性对数阶O(nlog(n)):
* 平方阶O(n²): 例如给公司每个部门的所有同事打招呼。
* 指数阶O(2^n):

### 2. 线性数据结构

#### (1) 数组

数组是存放在连续内存空间上的**相同类型数据**的集合。注意：在Python中的`list`，`tuple`，`set`等都不属于数组。

- 优点：访问数据简单。可以直接访问目标数据。
- 缺点：添加和删除数据比较耗时间。数据添加、删除需要移动其他数据。
- 使用场景：频繁查询，对存储空间要求不大，很少增加和删除的情况。
- 查询复杂度：由于可以直接访问，查询复杂度是O(1)

#### (2) 链表

链表是物理存储单元上非连续的存储结构，每个元素包含两个结点，一个是存储元素的数据域(内存空间)，另一个是指向下一个结点地址的指针域。

- 优点：数据添加和删除方便。Blue -> Yellow -> Red，想要插入一个数据Green，只需要将Blue的指针指向变成Green，把Green的指针指向Yellow。
- 缺点：访问比较耗费时间。想要访问数据，只能从第一个数据开始，顺着指针的指向逐一往下访问。
- 适用场景：数据量较小，需要频繁增加，删除操作的场景。
- 查询复杂度：查询最后一个数据，需要从第一个开始，时间复杂度是O(n)

#### (3) 栈

栈也是一种数据呈线性排列的数据结构，不过在这种结构中，我们只能访问最新添加的数据。从栈顶放入元素的操作叫入栈，取出元素叫出栈。

- 查询复杂度：由于查询最先添加的数据，需要依次上往下查询，时间复杂度是O(n)

#### (4) 队列

队列中的添加和删除数据的操作分别是在两端进行的。队列可以在一端添加元素，在另一端取出元素。

- 查询复杂度：由于查询最后添加的数据，需要依次前往后查询，时间复杂度是O(n)

### 3. 非线性数据结构

#### (1) 哈希表

哈希表是根据key和value直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。

一般来说，我们可以把键当作数据的标识符，把值当作数据的内容。

例如，下表中key为人名，value为性别，我们要查Joe的性别，可以首先计算Joe的哈希值例如是4928，再将这个数取mod 5，得到3，这样就能知道Joe的性别是男。

| 内存地址 | key | value |
|------|-----|-------|
| 3    | Joe | M     |
| 4    | Sue | F     |
| 5    | Dan | M     |

此时如果有一个人Nell，它的6279，mod 5之后的值为4，此时由于4已经被Sue给占据了，此时可使用链表在已有的数据的后面继续存储新的数据。


| 内存地址 | key | value |      |     |
|------|-----|-------|------|-----|
| 3    | Joe | M     |      |     |
| 4    | Sue | F  -> | Nell | M   |
| 5    | Dan | M     |      |     |

- 时间复杂度: Hash Map的时间复杂度是O(1)，因为哈希表的设计可以基于数组，数组基于顺序的内存地址，所以数组访问元素时间复杂度是O(1)。
但是考虑到哈希碰撞，不同的key由哈希函数得到的value相同，此时有可能时间复杂度达到O(n)。

#### (2) 树

1. 二叉树: 每个节点最多有两颗子节点。左子树的节点值比父亲节点小，而右子树的节点值比父亲节点大。

- 优点：在查找某个节点的时候，可以采取类似于二分查找的思想，快速找到某个节点。
- 缺点：二叉树可能会在极端情况下退化为链表。例如下图所示。
```bash
     9
   5 10
  4
 3
2
```

- 查询复杂度：O(logn)

2. 平衡二叉树: 具有二叉查找树的全部特性。每个节点的左子树和右子树的高度差至多等于1。

平衡二叉树: 左子树高度3，右子树高度为2。
```bash
    9
  5 10
4
```
非平衡二叉树:左子树高度4，右子树高度为2。
```bash
   9
  5 10
 4
3
```
对于普通二叉树出现的极端情况下，退化为链表的情况，二叉树可以通过左旋和右旋来解决。

- 左旋: 例如下面的例子(这种属于R-R型的，都在右边)，将13逆时针旋转(左旋)，此时就可以得到平衡的二叉树
```bash
13
 24
  37
```
旋转后
```bash
  24
13 27
```


- 右旋：例如下面的例子(这种属于L-L型的，都在左边)，将9顺时针旋转(右旋)，此时就可以得到平衡的二叉树
```bash
  9
 5
4
```
旋转后
```bash
 5
4 9
```

3. 红黑树: 红黑树在二叉树的基础上增加了着色。红黑树有如下要求：
- 每个节点必须着色，要么是红色，要么是黑色
- 根节点必须是黑色的
- 红节点的孩子必须是黑色的，不能是红色的

N表示空节点
```bash
          8(B)
   1(R)         11(R)
N(B)  6(B)    N(B) N(B)
    N(B) N(B)
```
- 优势：相比于平衡二叉树，红黑树的插入和删除需要的旋转更少
- 劣势：如果查找较多，而删除、插入较少，平衡二叉树更好。  

4. B树: B树称为平衡多路查找树(不止两个)。

下图所示，B树要查找字母E，方法为：首先和M比较，小于M，定位到左边；然后和D，G比较，在D和G中间；此时定位到E和F，和E一样大，定位到E。

```bash
                        M
 D              G               Q                T
A C    E F    H K L            N P     R S    W X Y Z
```
- 优势: B树在每个节点保存更多的数据，减少了树的高度，从而提升了查找的性能

6. B+树: B+树的非叶子节点不保存具体的数据，而只保存关键字的索引，**所有的数据最终都会保存到叶子节点**。
```bash
                        0005
          0003                       0007              
    0002          0004     0006           0008 0009          
0001->0002->0003->0004->0005->0006->0007->0008->0009->0010
```

- 优势：

(1) 相比于B树, 由于非叶子节点不存储数据，因此能存储更多的索引。

(2) 相比于B树，查询速度更稳定，因为B树有可能会在根节点就查询到数据，有可能在叶子节点查询到数据。

#### (3)堆

#### (4) 图

## 十、个人简历

### 1. 鉴权是如何完成的?

继承了drf的BasePermission类，去实现这个类的has_permission方法。方法主要的思路是将请求里的token进行解密，获取到用户的信息，判断用户的权限。
在视图函数中，会在请求之前去对用户权限做判断。此外，在CBV中，还可以指定要判断哪些请求，有可能有些用户可能访问部分请求。

### 2. 如何模仿FileZilla的?

web上实现FileZilla主要分如下几步

- 用户进入导出页面时，首先从token中获取用户信息，判断用户之前是否有输入过IP，端口，用户名，密码，磁盘路径登信息。如果用户是首次做导出操作，需要 手动输入IP等信息。如果用户已经输入过，此时就不再输入(密码除外)
  。如果用户需要对输入的信息做修改，需要在数据库中进行更新。
- 登录上远程服务器后，对于首次导出的用户，会从根目录开始遍历。对于已经导出过的用户，从用户输入的磁盘路径开始遍历。
- 用户选择好路径之后，会开始进行导出。由于导出是耗时操作，会做异步处理。
- 此时需要通过手动刷新导出列表来判断是否所有文件全部导出完成。

### 3. 算法平台数据上传的异步是如何做的?

上传文件的时候，首先对文件obj转成base64，因为CELERY不支持支持传不能序列化的参数。

在异步的任务中，首先将文件做一个decode，然后拿到文件obj之后，对文件obj保存到服务器中，再做后续处理。

### 4. 数据转换平台如何实现的提升转换速度?

原因是合并的时候采用了group_by，而没有用多层的for循环嵌套。

### 5. nii数据如何可视化?

nii -> sitk -> numpy -> base64

### 6. 算法平台缓存的策略

对于计算比较复杂，但是数据更新不频繁的结果数据，做了缓存。例如最近一个月跑模型统计，存成一个队列做缓存，到队列里，每次有数据更新，只需要对最后一
天的数据做更新即可，采用`python`的`redis`包。存`RPUSH(key, *list)`，更新`LSET(key, index, value)`。

### 7. 数据平台如何实现的rsync同步?

在web页面上，用户点击同步按钮时触发。在代码层面主要是调用`subprocess`来模拟终端的rsync操作，来实现数据平台服务器和算法服务器之间的数据同步。
当数据平台服务器有数据新增时，rsync可以检查两个服务器，来传输仅有变动的部分。

### 8. 聊一下数据库设计的思路

- 数据库的设计一定要在代码开发之前，设计的数据库能满足业务全生命周期
- 主键和外键
- 索引：主键索引、唯一索引

### 9. 医学部分

#### (1) dicom，nii，numpy，base64转换

- dicom转nii: simpleitk
- nii转numpy: simpleitk
- numpy转str: Pillow

#### (2) 传统PACS工作站模式

PACS(Picture Archiving and Communication System): 存储和分发医学影像、信息(例如病人抽血信息也在PACS里)的系统。

- Picture: 医学影像
- Archiving: 存储/归档(服务器)
- Communication: 网络通讯
- System: 系统工程

#### (3) RIS

放射信息系统(RIS, Radiology information system)，放射信息管理系统。主要用来登记预约、排队叫号、技师模块、报告模块、主任模块、采集模块。

### 10. DevOps

#### (1) 为什么需要k8s?

因为采用容器部署，会出现如下问题：

- 一个容器故障停机了，怎么让另外一个容器去替补停机的容器？例如Nginx这个容器挂了，怎么让替补上场？
- 如果并发访问量突然增大，怎么横向扩展容器数量。并发访问量恢复正常之后，如何恢复正常数目的容器数？

#### (2) 算法如何用于到IT运维中?

- 机器学习算法可以通过历史数据和趋势分析，预测系统资源的使用情况和未来的容量需求。例如有些运维日志需要清理，如果清理太频繁，会导致无法排查到历史信
息。如果清理太不频繁，此时容量又会满。可以利用机器学习算法来预测内存使用的情况。
- 故障分类：通过读取故障发生时的一些基本参数，来判断出现故障的原因，具体是什么原因导致的故障。

#### (3) 谈一下对DevOps的理解?

开发人员将代码写好后，可能会经历下面两个过程。

1. 开发和测试的反复沟通: 开发 -> 测试 -> 开发 -> 测试....完成测试
2. 开发人员写好部署手册，交给运维。开发和运维的反复沟通: 开发 -> 运维 -> 开发 -> 运维

这种并不是一种理想化的串行的工作方式。

在敏捷开发里，把大的产品拆分成多个短周期的迭代，每个迭代都是可以交付给客户的单位，每个迭代由可以拆分成多个user story(用户故事点)，用户故事点就
是一个可以持续集成的单位。这样就可以最快速的朝后续交付，减少岗位后续的等待时间。

在DevOps中，就是去实现从代码打包到产品交付给客户整个过程最大限度的自动化，这样可以有效的加快产品的上线时间。devops工程师的角色就是去建立这样一
条自动化的流水线并且去维护这条流水线，确保效能最大化。

目前建立流水线主要的工具是Jenkins，Sonarqube自动化测试工具。

#### (4) devops平台的设计该怎么做(针对数坤)

1. 平台目标: 构建、测试、发布软件更加快捷、频繁和可靠
2. 平台数据：
    - 一个版本的全生命周期数据: 代码版本，开发周期，发布次数，发布延迟时间，开发人员，测试人员，构建人员。
    - 测试结果: 例如测试用例，测试环境，测试版本。
    - 构建结果: 构建环境(例如服务版本信息、环境配置信息)，构建时间。
    - 项目信息: 平台应该能够记录和跟踪项目的信息。这些信息应该包括项目名称、项目描述、项目状态、项目时间表等
    - bug数量: 可以用sonarqube去获取代码的错误，漏洞。
3. 发布定义:
    - 环境变量配置: 用户可以自己定义，不需要
    - 任务编排: 发布的时候，需要启动哪些东西: 例如框架，异步的celery worker，redis
4. 排查: 开发人员通过devops平台查看研发、测试、生成各个环节中的日志。
5. 平台使用者: 开发和测试

#### (5) Jenkins的作用是啥?

Jenkins是一个持续集成(CI)和持续交付(CD)工具，用于构建、测试和部署软件。Jenkins可以自动从代码仓库中拉取代码，执行构建、测试和部署任务，并将任
务结果反馈给开发人员和测试人员，例如可以在Jenkins中配置邮件。

#### (6) Sonarqube的作用是啥?

Sonarqube是一款自动化代码检测工具，可以用它来检测代码中的错误、漏洞和代码异味。

#### (7) 为什么需要ansible?

ansible实现了批量系统配置、批量程序部署、批量运行命令。

假设有一个公司有10台服务器需要安装Web服务器，传统的方法是手动在每台服务器上安装和配置Web服务器，而使用Ansible可以通过编写Playbook来自动在10
台服务器上安装和配置Web服务器，节省了大量的时间和精力。下面是一个Playbook。

```yaml
- name: Install Nginx  # Playbook的名称
  hosts: web_servers  # 指定需要执行Playbook的主机组
  become: true  # 在执行任务时使用sudo权限

  tasks:  # 包含多个任务, 每个任务都有一个名称和一个或多个模块
  - name: Update apt cache
    apt:
      update_cache: yes

  - name: Install Nginx
    apt:
      name: nginx
      state: present

  - name: Start Nginx
    service:
      name: nginx
      state: started
```

在Ansible中，可以使用SSH协议连接到其他主机并执行命令。在Playbook中指定其他主机时，Ansible会使用SSH协议连接到这些主机并执行任务。在执行任务
时，Ansible会将任务的指令发送到远程主机，然后在远程主机上执行指令，最后将结果返回给控制节点。

#### (8) SaltStack的作用是啥?

SaltStack的出现是为了解决传统运维工作中存在的一些问题，包括：

- 手动操作繁琐：传统运维工作需要手动登录每台服务器，执行命令、部署软件等操作，这样的操作效率低下且容易出错。SaltStack可以远程执行命令，从而避
免了管理员需要手动登录服务器执行命令的过程。

- 管理复杂度高：随着业务规模的扩大，服务器数量和网络设备数量也不断增加，管理和配置变得越来越复杂。

### 11. 微服务

### 1. 单体应用的缺陷?

- 代码臃肿
- 容错性差，某个小功能错误可能导致整个系统宕机
- 开发协作困难，一个大型项目，可能几十个开发人员，代码merge复杂度

### 2. 微服务的优势?

- 某些模块开发好之后，可以直接去使用这个微服务(例如消息中心、人员中心)，而不用另外再开发一套重复的代码

### 3. 什么是微服务?

- 单一职责的: 一个微服务应该都是单一职责的，这才是"微"的体现，一个微服务解决一个业务问题(注意是一个业务问题而不是一个接口)
- 面向服务的: 将自己的业务能力封装并对外提供服务，一个微服务本身也可能使用到其它微服务的能力

### 4. 使用微服务的方法

- HTTP
- gRPC
- 消息队列

### 5. gRPC使用微服务

- 定义protobuf文件, protobuf中需要定义
```proto

# Greeter是服务名称
service Greeter {
    # SayHello: 方法名称。在服务端中实现方法, 客户端中调用方法。 
    # HelloRequest: 请求的传参
    # HelloReply: 返回数据
	rpc SayHello (HelloRequest) returns (HelloReply);
}
message HelloRequest {
  # 1和2代表请求的第一个和第二个参数
  string name = 1;
  string greeting = 2;
}

message HelloReply {
  # 1代表返回的第一个数据
  string message = 1;
}
```
- 编译protobuf文件，生成分别以`pb2`和`pb2_grpc`为后缀的py文件，其中`pb2`用来和`protobuf`数据进行交互，`pb2_grpc`用来和grpc交互
- 服务端: 实现protobuf中定义的方法
- 客户端: 调用protobuf中定义的方法
- 必要时，可以打包成pip包

### 6. 视频转mp3的例子

- 网关作为整个系统的入口，处理客户端的请求
- 用户登录，[网关]调用[认证微服务]，判断用户用户名/密码是否匹配，如果匹配返回token给用户
- 用户携带jwt，发送上传视频请求
- [网关]调用[认证微服务]，通过解密jwt判断token是否有效
- [网关]存储视频(MongoDB)，并给[消息队列]发消息
- [视频转mp3微服务]从[消息队列]中消费任务，从消息队列中拿到视频的id。从MongoDB中拿到视频，并将其转为mp3，并将mp3存到MongoDB中
- [视频转mp3微服务]给[消息队列]发消息，告诉它转换已经完成
- [消息通知微服务]从[消息队列]中消费任务，然后给用户发送email，邮件里告诉用户mp3的id
- 浏览器通过mp3的id，以及用户的token，发送一个下载请求
- [网关]处理下载请求，并从MongoDB中取出mp3，将mp3返给用户



