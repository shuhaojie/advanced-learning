# 从根儿上理解MySQL

- 选自<https://juejin.cn/book/6844733769996304392/>

## 一、预备知识

### 1. 可执行文件

- MacOS安装目录：`/usr/local/mysql/bin`，里面有非常多的可执行文件，启动客户端程序和服务端程序都可以通过执行可执行文件来完成。

```bash
➜  bin ls -la
-rwxr-xr-x   1 root  wheel    8867936  7  7  2022 mysql  # 启动客户端
-rwxr-xr-x   1 root  wheel       5002  7  7  2022 mysql_config
-rwxr-xr-x   1 root  wheel    9235680  7  7  2022 mysqlbinlog
-rwxr-xr-x   1 root  wheel    8498064  7  7  2022 mysqlcheck
-rwxr-xr-x   1 root  wheel   74288112  7  7  2022 mysqld  # 启动服务端
...
```

### 2. 客户端与服务端连接

- MySQL采用的是TCP协议，服务端默认监听3306端口，因此客户端需要去连接到3306端口

- **如果我们的服务器进程和客户端进程都运行在同一台操作系统为类`Unix`的机器上的话**，我们可以使用`Unix域套接字文件`来进行进程间通信，连接方式`mysql --socket=/tmp/mysql.sock -u {username} -p`。如果客户端程序和服务器程序不运行在一台计算机上，我们还可以采用使用了`SSL`（安全套接字）的网络连接进行通信，来保证数据传输的安全性。

> 注：每个操作系统对应的socket文件路径不一样，具体socket文件位置路径，可以通过`mysqladmin -p -u {username} variables`命令来查看，这个命令非常神奇

- 使用MySQL时，**需要首先启动服务端，再启动客户端**，然后在客户端程序中输入一些命令语句作为请求发送到服务器程序

### 3. 服务端处理客户端请求

客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）

<img src="assets/image-20230506231125514.png" alt="image-20230506231125514" style="zoom:80%;" />

#### （1）连接管理

每当有一个客户端进程连接到服务器进程时，MySQL服务器进程都**会创建一个线程**来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并**不会立即把与该客户端交互的线程销毁掉**，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求，`MySQL`服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理。

可以通过`SHOW PROCESSLIST`来查看客户端连接情况

```mysql
mysql> SHOW PROCESSLIST;
+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+
| Id | User            | Host            | db   | Command | Time  | State                  | Info             |
+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+
|  5 | event_scheduler | localhost       | NULL | Daemon  | 13829 | Waiting on empty queue | NULL             |
|  8 | root            | localhost       | auth | Query   |     0 | init                   | SHOW PROCESSLIST |
| 10 | root            | localhost:61671 | auth | Sleep   |  9008 |                        | NULL             |
| 15 | root            | localhost       | NULL | Sleep   |   763 |                        | NULL             |
+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+
4 rows in set, 1 warning (0.01 sec)
```

这里

- User：代表连接的用户
- Time：代表连接的时间，单位是秒
- Command：代表命令，"Sleep" 状态**表示连接处于空闲状态，即客户端当前没有活动**。当我们创建一个连接，而没有关闭这个连接时，其状态就是Sleep。

```python
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://root:root@127.0.0.1:3306/auth'
app.config['SQLALCHEMY_DATABASE_URI'] = SQLALCHEMY_DATABASE_URI
db = SQLAlchemy(app)
session = db.session

@app.route('/post_file_sync', methods=['POST'])
def post_file_sync():
    data = request.json
    session.query(User).filter(User.email == data["email"]).delete()
    session.commit()
    session.close()
    return jsonify({"message": "success"}), 200
```

在上面代码中

- 程序最后的`session.close()`命令，也**并不会去关闭MySQL服务器上的连接**。在SQLAlchemy中，session，engine和connection的具体区别，可以参考MySQL的文档，有非常详细的说明。

  > sesssion就好比你在餐厅，客人点了一份汉堡，你不会立刻去做，而是把它写在订单上，然后等到一桌订单都写好了，才会开始制作。session就像是这张订单，它可以暂存你的操作，然后一次性提交。

- 如果想关闭MySQL服务器上的连接，可以采用如下的形式

```python
engine_container = db.get_engine(app)
session.close()  # 关闭session
engine_container.dispose() # 关闭数据库连接
```

#### （2）解析与优化

MySQL服务器获得文本形式的请求后，还要经过九九八十一难的处理，其中的几个比较重要的部分分别是`查询缓存`、`语法解析`和`查询优化`

##### a. 查询缓存

如果我问你`9+8×16-3×2×17`的值是多少，我们计算得到结果`35`，如果我再问你一遍`9+8×16-3×2×17`的值是多少，由于刚刚已经算过了，直接说答案就好了。`MySQL`服务器程序处理查询请求的过程也是这样，会把刚刚处理过的查询请求和结果`缓存`起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了。

不过既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，**如对该表使用了`INSERT`、 `UPDATE`、`DELETE`等语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除**

> 由于维护缓存需要造成一些开销，从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。

##### b. 语法解析

如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以`MySQL`服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到`MySQL`服务器内部使用的一些数据结构上来。

##### c. 查询优化

语法解析之后，服务器程序获得到了需要的信息，但我们写的`MySQL`语句执行起来效率可能并不是很高，`MySQL`的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接等。**优化的结果就是生成一个执行计划**，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的，我们可以使用`EXPLAIN`语句来查看某个语句的执行计划。

```bash
mysql> explain select * from user;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

##### d. 存储引擎

**`MySQL`服务器把数据的存储和提取操作都封装到了一个叫`存储引擎`的模块里**，知道`表`是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是`存储引擎`负责的事情。

### 4. 启动选项

- 在Mysql中，可以修改很多选项，例如如果我们在启动服务器程序的时候就禁止各客户端使用`TCP/IP`网络进行通信，可以在启动服务器程序的命令行里添加`skip-networking`启动选项，就像这样：

  ```mysql
  mysqld --skip-networking
  ```

  按照上述命令启动服务器程序后，如果我们再使用`mysql`来启动客户端程序时，再把服务器主机名指定为`127.0.0.1`（IP地址的形式）的话会显示连接失败

- 也可以把这些启动选项写在配置文件中，这样做的好处是不必每次启动mysql服务，都再次把配置再写一遍，

  在unix系统中，**mysql按照如下顺序去找配置，优先读前面路径的配置**。

  | 路径名                | 备注                                 |
  | --------------------- | ------------------------------------ |
  | `/etc/my.cnf`         |                                      |
  | `/etc/mysql/my.cnf`   |                                      |
  | `SYSCONFDIR/my.cnf`   |                                      |
  | `$MYSQL_HOME/my.cnf`  | 特定于服务器的选项（仅限服务器）     |
  | `defaults-extra-file` | 命令行指定的额外配置文件路径         |
  | `~/.my.cnf`           | 用户特定选项                         |
  | `~/.mylogin.cnf`      | 用户特定的登录路径选项（仅限客户端） |

  例如我们可以手动创建一个配置，`/etc/my.cnf`

  ```bash
  [mysqld]
  port = 3306
  character_set_server = utf8mb4
  log_error = /var/log/mysql/error.log
  slow_query_log = 1
  slow_query_log_file = /var/log/mysql/slow-query.log
  long_query_time = 2
  key_buffer_size = 16M
  innodb_buffer_pool_size = 128M
  max_connections = 100
  bind-address = 127.0.0.1
  ```
  
  服务端启动`mysqld`的时候，就会去读这个配置

### 5. 系统变量

`MySQL`服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为`MySQL`系统变量，比如允许同时连入的客户端数量用系统变量`max_connections`表示。

### （1）查看系统变量

可以使用下列命令查看`MySQL`服务器程序支持的系统变量以及它们的当前值：

```mysql
mysql> SHOW VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
1 row in set (0.01 sec)

mysql> SHOW VARIABLES like 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 151   |
+-----------------+-------+
1 row in set (0.00 sec)
```

### （2）设置系统变量

可以通过两种方式来来进行设置。

1. 通过命令行添加启动选项

```mysql
mysqld --default-storage-engine=MyISAM --max-connections=10
```

2. 通过配置文件添加启动选项

```bash
[server]
default-storage-engine=MyISAM
max-connections=10
```

当使用上边两种方式中的任意一种启动服务器程序后，我们再来查看一下系统变量的值：

```bash
mysql> SHOW VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | MyISAM |
+------------------------+--------+
1 row in set (0.00 sec)

mysql> SHOW VARIABLES LIKE 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 10    |
+-----------------+-------+
1 row in set (0.00 sec)
```

### （3）变量范围

变量范围有两种

- `GLOBAL`：全局变量，影响服务器的整体操作。
- `SESSION`：会话变量，影响某个客户端连接的操作。（注：`SESSION`有个别名叫`LOCAL`）

服务器启动时，会将每个【全局变量】初始化为其默认值，然后服务器还为每个连接的客户端维护一组【会话变量】，客户端的【会话变量】在连接时使用相应全局变量的当前值初始化。以`default_storage_engine`举例，在服务器启动时会初始化一个名为`default_storage_engine`，作用范围为`GLOBAL`的系统变量。之后每当有一个客户端连接到该服务器时，服务器都会单独为该客户端分配一个名为`default_storage_engine`，作用范围为`SESSION`的系统变量，该作用范围为`SESSION`的系统变量值按照当前作用范围为`GLOBAL`的同名系统变量值进行初始化。

可以通过如下方式，来设置全局变量/会话变量。

```mysql
SET [GLOBAL|SESSION] 系统变量名 = 值;
SET [@@(GLOBAL|SESSION).]var_name = XXX;
```

如果我们想在服务器运行过程中把作用范围为`GLOBAL`的系统变量`default_storage_engine`的值修改为`MyISAM`，也就是想让之后新连接到服务器的客户端都用`MyISAM`作为默认的存储引擎，那我们可以选择下边两条语句中的任意一条来进行设置

```mysql
# 方式一
SET GLOBAL default_storage_engine = MyISAM;
# 方式二
SET @@GLOBAL.default_storage_engine = MyISAM;
```

如果只想对本客户端生效，也可以选择下边三条语句中的任意一条来进行设置：

```mysql
# 方式一
SET SESSION default_storage_engine = MyISAM;
# 方式二
SET @@SESSION.default_storage_engine = MyISAM;
# 方式三
SET default_storage_engine = MyISAM;
```

既然`系统变量`有`作用范围`之分，那我们的`SHOW VARIABLES`语句查看的是什么`作用范围`的`系统变量`呢？

答：默认查看的是`SESSION`作用范围的系统变量。

下面是一个完整的示例，来理解这个

```mysql
mysql> SHOW SESSION VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
1 row in set (0.00 sec)

mysql> SHOW GLOBAL VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
1 row in set (0.00 sec)

mysql> SET SESSION default_storage_engine = MyISAM;
Query OK, 0 rows affected (0.00 sec)

mysql> SHOW SESSION VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | MyISAM |
+------------------------+--------+
1 row in set (0.00 sec)

mysql> SHOW GLOBAL VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
1 row in set (0.00 sec)
```

> 在 MySQL 中，使用 `SET GLOBAL` 命令设置全局变量时并不会立即生效，因为它仅影响新启动的会话，而不会影响当前正在运行的会话。

### （4）状态变量

为了让我们更好的了解服务器程序的运行情况，`MySQL`服务器程序中维护了好多关于程序运行状态的变量，它们被称为`状态变量`。比方说`Threads_connected`表示当前有多少客户端与服务器建立了连接。

```mysql
mysql> SHOW STATUS LIKE 'thread%';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_cached    | 0     |
| Threads_connected | 1     |
| Threads_created   | 1     |
| Threads_running   | 1     |
+-------------------+-------+
4 rows in set (0.00 sec)
```

## 二、InnoDB行格式

### 1. 行格式简介

我们平时是以记录为单位来向表中插入数据的，**这些记录在磁盘上的存放方式也被称为`行格式`**。目前存在四种行格式，分别是`Compact`、`Redundant`、`Dynamic`和`Compressed`，默认是Compact。

```mysql
mysql> CREATE TABLE record_format_demo (
         c1 VARCHAR(10),
         c2 VARCHAR(10) NOT NULL,
         c3 CHAR(10),
         c4 VARCHAR(10)
     ) CHARSET=ascii ROW_FORMAT=COMPACT;
mysql> INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);
```

### 2. Compact行格式

<img src="assets/image-20240426211522504.png" alt="image-20240426211522504" style="zoom:50%;" />

从图中可以看出来，**一条完整的记录其实可以被分为`记录的额外信息`和`记录的真实数据`两大部分**，下边我们详细看一下这两部分的组成。

#### （1）变长字段长度列表

MySQL支持一些变长的数据类型，比如VARCHAR，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把`MySQL`服务器搞懵，所以这些变长字段占用的存储空间分为两部分：【真正的数据内容】和【占用的字节数】。在`Compact`行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而**形成一个变长字段长度列表**，各变长字段数据占用的字节数按照列的顺序**逆序存放**。

以上面数据为例，`record_format_demo`表的`c1`、`c2`、`c4`列数据长度分别为04，02，01，因此变长字段长度列表为

<img src="assets/image-20240426212740038.png" alt="image-20240426212740038" style="zoom:50%;" />

另外需要说明的是，对于`c3`列的类型是`CHAR(10)`，当我们的`record_format_demo`表采用的是`ascii`字符集（定长字符集）时，c3列的长度不会存储到`变长字段长度列表`中。**如果采用变长的字符集，例如`gbk`（表示一个字符要1～2个字节），`utf8`（表示一个字符要1~3个字节）的话，`c3`列的长度也会被存储到`变长字段长度列表`中**。

#### （2）NULL值列表

MySQL表中的某些列可能存储`NULL`值，如果把这些`NULL`值都放到`记录的真实数据`中存储会很占地方，所以`Compact`行格式把这些值为`NULL`的列统一管理起来，存储到`NULL`值列表中，它的处理过程是这样的。

- 首先统计表中允许存储`NULL`的列有哪些。
- 将每个允许存储`NULL`的列**对应一个二进制位**，二进制位的值为`1`时，代表该列的值为`NULL`，二进制位的值为`0`时，代表该列的值不为`NULL`。 NULL值列表**同样是逆序存放**。

MySQL规定**NULL值列表必须用整数个字节的位表示**，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。所以对于上面两条数据，NULL值列表示意图就是这样：

<img src="assets/image-20240426215347630.png" alt="image-20240426215347630" style="zoom:50%;" />

<img src="assets/image-20240426215023598.png" alt="image-20240426215023598" style="zoom:50%;" />

#### （3）记录头信息

除了`变长字段长度列表`、`NULL值列表`之外，还有一个用于描述记录的`记录头信息`，它是由固定的`5`个字节组成。`5`个字节也就是`40`个二进制位，不同的位代表不同的意思。这些二进制位代表的详细信息如下表，现在不需要了解非常详细，下一节会重点介绍。

<img src="assets/image-20240427154036594.png" alt="image-20240427154036594" style="zoom:40%;" />

到目前为止，这两条数据长这样

<img src="assets/image-20240427154239882.png" alt="image-20240427154239882" style="zoom:40%;" />

#### （4）主键

在MySQL中，除了我们自己定义的列的数据以外，**MySQL会为每个记录默认的添加一些列**，具体的列如下：

| 列名             | 是否必须 | 占用空间 | 描述                   |
| ---------------- | -------- | -------- | ---------------------- |
| `row_id`         | 否       | `6`字节  | 行ID，唯一标识一条记录 |
| `transaction_id` | 是       | `6`字节  | 事务ID                 |
| `roll_pointer`   | 是       | `7`字节  | 回滚指针               |

补充说明一下，InnoDB中，**表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则`InnoDB`会为表默认添加一个名为`row_id`的隐藏列作为主键**，因此可以说InnoDB中，**表一定有主键**。

所以我们从上表中可以看出：`transaction_id` 和 `roll_pointer` 这两个列是必须的，但是`row_id` 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心，`InnoDB`存储引擎会自己帮我们生成的。

#### （5）记录的真实数据

到目前为止，两条数据长这样：

<img src="assets/image-20240427161102979.png" alt="image-20240427161102979" style="zoom:50%;" />

这里需要说明的是：

1. 表`record_format_demo`使用的是`ascii`字符集，所以`0x61616161`就表示字符串`'aaaa'`，`0x626262`就表示字符串`'bbb'`，以此类推。
2. 注意第1条记录中`c3`列的值，它是`CHAR(10)`类型的，它实际存储的字符串是：`'cc'`，而`ascii`字符集中的字节表示是`'0x6363'`，虽然表示这个字符串只占用了2个字节，但整个`c3`列仍然占用了10个字节的空间，**除真实数据以外的8个字节的统统都用空格字符填充，空格字符在`ascii`字符集的表示就是`0x20`**。
3. 注意第2条记录中`c3`和`c4`列的值都为`NULL`，它们被存储在了前边的`NULL值列表`处，在记录的真实数据处就不再冗余存储，从而节省存储空间。

### 3. Redundant行格式

### 4. Dynamic和Compressed行格式

## 三、InnoDB数据页

`MySQL`服务器上负责对表中数据的读取和写入工作的部分是`存储引擎`，服务器支持不同类型的存储引擎，比如`InnoDB`、`MyISAM`、`Memory`，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，**真实数据在不同存储引擎中存放的格式一般是不同的**，甚至有的存储引擎比如`Memory`都不用磁盘来存储数据。

### 1. InnoDB页简介

`InnoDB`是一个**将表中的数据存储到磁盘上**的存储引擎，所以即使关机后重启我们的数据还是存在的。而**真正处理数据的过程是发生在内存中的**，所以**需要把磁盘中的数据加载到内存中**，**如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上**。我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，`InnoDB`存储引擎需要一条一条的把记录从磁盘上读出来么？那样会慢死，`InnoDB`采取的方式是：将数据划分为若干个页，**以页作为磁盘和内存之间交互的基本单位**，InnoDB中页的大小一般16KB。也就是在一般情况下，**一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中**。

### 2. 数据页

`InnoDB`为了不同的目的而设计了许多种不同类型的`页`，比如存放表空间头部信息的页，存放`undo`日志信息的页等等。这些页没有听过没有关系，我们聚焦存放我们表中记录的那种类型的页：`数据页`。数据页代表的这块`16KB`大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示。

<img src="assets/image-20240428221059398.png" alt="image-20240428221059398" style="zoom:30%;" />

| 名称                 | 中文名             | 占用空间大小 | 简单描述                 |
| -------------------- | ------------------ | ------------ | ------------------------ |
| `File Header`        | 文件头部           | `38`字节     | 页的一些通用信息         |
| `Page Header`        | 页面头部           | `56`字节     | 数据页专有的一些信息     |
| `Infimum + Supremum` | 最小记录和最大记录 | `26`字节     | 两个虚拟的行记录         |
| `User Records`       | 用户记录           | 不确定       | 实际存储的行记录内容     |
| `Free Space`         | 空闲空间           | 不确定       | 页中尚未使用的空间       |
| `Page Directory`     | 页面目录           | 不确定       | 页中的某些记录的相对位置 |
| `File Trailer`       | 文件尾部           | `8`字节      | 校验页是否完整           |

#### （1）记录在页中的存储

在页的7个组成部分中，**我们自己存储的记录会按照我们指定的`行格式`存储到`User Records（用户记录）`部分**。但是在一开始生成页的时候，其实并没有`User Records`这个部分（对应下图第一张图），每当我们插入一条记录，都会从`Free Space`部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到`User Records`部分，当`Free Space`部分的空间全部被`User Records`部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

<img src="assets/image-20240502090707403.png" alt="image-20240502090707403" style="zoom:50%;" />

#### （2）记录头信息详解

前面说过记录头信息，但是并没有详细介绍，这里再详细看看。我们先创建一个表

```mysql
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)
```

这个表中记录的行格式示意图如下所示：

<img src="assets/16a95c0feca77be3~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.png" alt="16a95c0feca77be3~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75" style="zoom:70%;" />

`记录头信息`由5个字节组成，再次把这些`记录头信息`中各个属性的大体意思浏览一下。头信息中一共有6个属性，`delete_mask`，`min_rec_mask`，`n_owned`，`heap_no`，`record_type`，`next_record`，需要好好掌握一下。

<img src="assets/image-20240427154036594.png" alt="image-20240427154036594" style="zoom:40%;" />

往数据库里插入4条数据，来观察效果

```mysql
mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
```

插入后，4条数据的头信息长这样

<img src="assets/image-20240502204217130.png" alt="image-20240502204217130" style="zoom:50%;" />

- `delete_mask`：这个属性标记着当前记录是否被删除，占用1个二进制位，值为`0`的时候代表记录并没有被删除，为`1`的时候代表记录被删除掉了。**这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已**。

- `min_rec_mask`：B+树的每层**非叶子节点**中的最小记录都会添加该标记。

- `n_owned`：每个组的**最后一条记录**的头信息中的`n_owned`属性表示该记录拥有多少条记录，也就是该组内共有几条记录。

- `heap_no`：这个属性**表示当前记录在本`页`中的位置**，从图中可以看出来，我们插入的4条记录在本`页`中的位置分别是：`2`、`3`、`4`、`5`。没有`0`和`1`，这是因为每个页里边儿加了两个记录，一个代表`最小记录(infimum)`，一个代表`最大记录(supremum)`。这两条记录不是我们自己定义的记录，所以它们并不存放在`页`的`User Records`部分，他们被单独放在一个称为`Infimum + Supremum`的部分，如图所示：

<img src="assets/image-20240506195444047.png" alt="image-20240506195444047" style="zoom:67%;" />

- `record_type`，这个属性表示当前记录的类型，一共有4种类型的记录，`0`表示普通记录，**`1`表示B+树非叶节点记录**（B+树索引会用到，叶节点中会有真实的数据记录），`2`表示最小记录，`3`表示最大记录。从图中我们也可以看出来，**我们自己插入的记录就是普通记录**。

- `next_record`：它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。**比方说第一条记录的`next_record`值为`32`，意味着从第一条记录的真实数据的地址处向后找`32`个字节便是下一条记录的真实数据**。`最大记录`的`next_record`的值为`0`，这也就是说最大记录是没有`下一条记录`了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：

  <img src="assets/image-20240502205708322.png" alt="image-20240502205708322" style="zoom:40%;" />

从图中可以看出来，删除第2条记录前后主要发生了这些变化：

- 第2条记录并没有从存储空间中移除，而是把该条记录的`delete_mask`值设置为`1`。
- 第2条记录的`next_record`值变为了0，意味着该记录没有下一条记录了。
- 第1条记录的`next_record`指向了第3条记录。
- `最大记录`的`n_owned`值从`5`变成了`4`，这一点的变化，后面详细说明。

所以，不论我们怎么对页中的记录做增删改操作，**InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的**。

### 3. 页目录(Page Directory)

#### （1）页目录和槽

现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，如果我们想根据主键值查找页中的某条记录该咋办呢？比如说这样的查询语句：

```mysql
SELECT * FROM page_demo WHERE c1 = 3;
```

最笨的办法：从`Infimum`记录（最小记录）开始，沿着链表一直往后找，总有一天会找到。但是一旦我们页中的数据增多时，这个方法便会很慢。MySQL的灵感来自于书本中的目录，我们翻书的时候想查找一些内容，就会去查看目录，然后直接确定好内容所在的页码，它的方案是这样的：

> 这里参考https://blog.51cto.com/u_13407532/3181653，https://xiaolincoding.com/mysql/index/page.html#innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84，手册上有点模糊

1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。

> 注意：也就是说，这些记录本质上还都在同一个页中

2. 每个组的**最后一条记录**（也就是组内最大的那条记录）的**头信息中的`n_owned`属性表示该记录拥有多少条记录**，也就是该组内共有几条记录。

3. **将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近`页`的尾部的地方**，这个地方就是所谓的`Page Directory`，也就是`页目录`。

上述地址偏移量就是该记录的真实数据与页面中第 0 个字节之间的距离，这些地址偏移量被称为槽，**每个槽相当于指针指向了不同组的最后一个记录**（注意这句话非常关键）。

> 【页目录】是【数据页】中和【用户记录】平级的存在，具体可以再回去看看前面的图

<img src="assets/image-20240523222719142.png" alt="image-20240523222719142" style="zoom:40%;" />

例如page_demo`表中正常的记录共有6条，`InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：

<img src="assets/image-20240503155904338.png" alt="image-20240503155904338" style="zoom:50%;" />

从这个图中我们需要注意这么几点：

- **`页目录`中有两个槽，说明记录被分成了两个组**。
- Infimum 记录的 n_owned 属性值为 1，而 Supremum 的为 5。

为什么这 6 条记录要这样分？因为作者对于每组中的记录数量有规定：

- 对于 Infimum 所在的分组只能有 1 条记录。
- Supremum 所在的分组只能在 1~8 条之间。
- 剩下的分组，记录条数范围只能是 4~8 之间。

所以分组是按照下边的步骤进行的：

- 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
- 之后每插入一条记录，都会从`页目录`中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的`n_owned`值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。

- 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在`页目录`中新增一个`槽`来记录这个新增分组中最大的那条记录的偏移量。

#### （2）页目录查找记录

现在我们新增一些数据

```mysql
mysql> INSERT INTO page_demo VALUES(5, 500, 'eeee'), (6, 600, 'ffff'), (7, 700, 'gggg'), (8, 800, 'hhhh'), (9, 900, 'iiii'), (10, 1000, 'jjjj'), (11, 1100, 'kkkk'), (12, 1200, 'llll'), (13, 1300, 'mmmm'), (14, 1400, 'nnnn'), (15, 1500, 'oooo'), (16, 1600, 'pppp');
```

这些记录被分成了5组

<img src="assets/image-20240515155050652.png" alt="image-20240515155050652" style="zoom:40%;" />

> 下面这部分好好琢磨，搞清楚对后面理解索引部分有好处

再回到最开始的问题，此时我们想查找主键值为6的记录，因为 5 个槽的编号分别为 0、1、2、3、4 挨着的，并且里面的主键值也都是从小到大进行排序的，可以使用二分法，那么初始情况下 low=0，high=4：可以按照如下方式：

1. 计算中间槽的位置：`(0+4)/2=2`，所以**查看`槽2`对应记录的主键值为`8`（**注意看图，槽2中的最大记录为8，这里直接在槽中就可以看到，不需要去到用户记录里去看），又因为`8 > 6`，所以设置`high=2`，`low`保持不变。
2. 重新计算中间槽的位置：`(0+2)/2=1`，所以查看`槽1`对应的主键值为`4`，又因为`4 < 6`，所以设置`low=1`，`high`保持不变。
3. 因为`high - low`的值为1，所以确定主键值为`6`的记录在`槽2`对应的组中。此刻我们需要找到`槽2`中主键值最小的那条记录，然后沿着单向链表遍历`槽2`中的记录。我们前边说过，每个槽对应的记录都是该组中主键值最大的记录，这里`槽2`对应的记录是主键值为`8`的记录，怎么定位一个组中最小的记录呢？由于各个槽都是挨着的，我们可以拿到`槽1`对应的记录（主键值为`4`），该条记录的下一条记录就是`槽2`中主键值最小的记录，该记录的主键值为`5`。从主键值为`5`的记录出发，遍历`槽2`中的各条记录，直到找到主键值为`6`的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。

### 4. 页面头部(Page Header)

`Page Header`是`页`结构的第二部分，这个部分占用固定的`56`个字节，专门存储各种状态信息

| 名称                | 占用空间大小 | 描述                                                         |
| ------------------- | ------------ | ------------------------------------------------------------ |
| `PAGE_N_DIR_SLOTS`  | `2`字节      | 在页目录中的槽数量                                           |
| `PAGE_HEAP_TOP`     | `2`字节      | 还未使用的空间最小地址，也就是说从该地址之后就是`Free Space` |
| `PAGE_N_HEAP`       | `2`字节      | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录） |
| `PAGE_FREE`         | `2`字节      | 第一个已经标记为删除的记录地址（各个已删除的记录通过`next_record`也会组成一个单链表，这个单链表中的记录可以被重新利用） |
| `PAGE_GARBAGE`      | `2`字节      | 已删除记录占用的字节数                                       |
| `PAGE_LAST_INSERT`  | `2`字节      | 最后插入记录的位置                                           |
| `PAGE_DIRECTION`    | `2`字节      | 记录插入的方向                                               |
| `PAGE_N_DIRECTION`  | `2`字节      | 一个方向连续插入的记录数量                                   |
| `PAGE_N_RECS`       | `2`字节      | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录） |
| `PAGE_MAX_TRX_ID`   | `8`字节      | 修改当前页的最大事务ID，该值仅在二级索引中定义               |
| `PAGE_LEVEL`        | `2`字节      | 当前页在B+树中所处的层级                                     |
| `PAGE_INDEX_ID`     | `8`字节      | 索引ID，表示当前页属于哪个索引                               |
| `PAGE_BTR_SEG_LEAF` | `10`字节     | B+树叶子段的头部信息，仅在B+树的Root页定义                   |
| `PAGE_BTR_SEG_TOP`  | `10`字节     | B+树非叶子段的头部信息，仅在B+树的Root页定义                 |

- `PAGE_DIRECTION`

  假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是`PAGE_DIRECTION`。

- `PAGE_N_DIRECTION`

  假设连续几次插入新记录的方向都是一致的，`InnoDB`会把沿着同一个方向插入记录的条数记下来，这个条数就用`PAGE_N_DIRECTION`这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。

### 5. 文件头部(File Header)

`Page Header`是专门针对`数据页`记录的各种状态信息，比方说页里头有多少个记录，有多少个槽。我们现在描述的`File Header`针对各种类型的页都通用，也就是说不同类型的页都会以`File Header`作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁。这个部分占用固定的`38`个字节，是由下边这些内容组成的：

| 名称                               | 占用空间大小 | 描述                                                         |
| ---------------------------------- | ------------ | ------------------------------------------------------------ |
| `FIL_PAGE_SPACE_OR_CHKSUM`         | `4`字节      | 页的校验和（checksum值）                                     |
| `FIL_PAGE_OFFSET`                  | `4`字节      | 页号                                                         |
| `FIL_PAGE_PREV`                    | `4`字节      | 上一个页的页号                                               |
| `FIL_PAGE_NEXT`                    | `4`字节      | 下一个页的页号                                               |
| `FIL_PAGE_LSN`                     | `8`字节      | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
| `FIL_PAGE_TYPE`                    | `2`字节      | 该页的类型                                                   |
| `FIL_PAGE_FILE_FLUSH_LSN`          | `8`字节      | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| `FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID` | `4`字节      | 页属于哪个表空间                                             |

对照着这个表格，我们看几个目前比较重要的部分：

- `FIL_PAGE_SPACE_OR_CHKSUM`：理解为md5就行
- `FIL_PAGE_OFFSET`：每一个`页`都有一个单独的页号，就跟你的身份证号码一样，`InnoDB`通过页号来可以唯一定位一个`页`。
- `FIL_PAGE_TYPE`：这个代表当前`页`的类型
- `FIL_PAGE_PREV`和`FIL_PAGE_NEXT`：`InnoDB`都是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），`InnoDB`可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，`FIL_PAGE_PREV`和`FIL_PAGE_NEXT`就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。所以所有的数据页其实是一个双链表，就像这样：

<img src="assets/image-20240503195504068.png" alt="image-20240503195504068" style="zoom:50%;" />

### 6. 文件尾部(File Trailer)

我们知道`InnoDB`存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以`页`为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，为了检测一个页是否完整，MySQL在每个页的尾部都加了一个`File Trailer`部分，这个部分由`8`个字节组成，可以分成2个小部分：

- 前4个字节：代表页的校验和

  这个部分是和`File Header`中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为`File Header`在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在`File Header`中的校验和就代表着已经修改过的页，而在`File Trailer`中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

- 后4个字节：代表页面被最后修改时对应的日志序列位置（LSN）

  这个部分也是为了校验页的完整性的，只不过我们目前还没说`LSN`是个什么意思，所以大家可以先不用管这个属性。

这个`File Trailer`与`File Header`类似，都是所有类型的页通用的。

## 四、B+树索引

### 1. 没有索引的查找

#### （1）在一个页中的查找

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：

- 以主键为搜索条件

  > 前面主键部分说过，MySQL中一定会有主键

  这个查找过程我们已经很熟悉了，可以在`页目录`中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

- 以其他列作为搜索条件

  由于在数据页中并没有对非主键列建立所谓的`页目录`，所以我们无法通过二分法快速定位相应的`槽`。这种情况下只能从`最小记录`开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

#### （2）在多个页中的查找

大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：

1. 定位到记录所在的页。
2. 从所在的页内中查找相应的记录。

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的。

### 2. 索引

首先建一个表

```mysql
mysql> CREATE TABLE index_demo(
    c1 INT,
    c2 INT,
    c3 CHAR(1),
    PRIMARY KEY(c1)
    ) ROW_FORMAT = Compact;
```

为了我们理解上的方便，简化一下`index_demo`表的行格式示意图，只保留记录头信息中的`record_type`和`next_record`两个字段：

- `record_type`：记录头信息的一项属性，表示记录的类型，`0`表示普通记录、`2`表示最小记录、`3`表示最大记录
- `next_record`：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量。

![image-20240504090036890](assets/image-20240504090036890.png)

#### （1）一个简单的索引方案

回顾我们为根据主键值快速定位一条记录在页中的位置而设立的页目录，我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录，建这个目录必须完成下边这些事儿：

- 下一个数据页中用户记录的**主键值**必须大于上一个页中用户记录的主键值。

- 给所有的页建立一个目录项。

由于数据页的编号可能并不是连续的，所以在向`index_demo`表中插入许多条记录后，可能是这样的效果：

![image-20240504153008207](assets/image-20240504153008207.png)

因为这些`16KB`的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：

1. 页的用户记录中最小的主键值，我们用`key`来表示。
2. 页号，我们用`page_no`表示。

所以我们为上边几个页做好的目录就像这样子：

<img src="assets/image-20240504155957880.png" alt="image-20240504155957880" style="zoom:50%;" />

以`页28`为例，它对应`目录项2`，这个目录项中包含着该页的页号`28`以及该页中用户记录的最小主键值`5`。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了。比方说我们想找主键值为`20`的记录，具体查找过程分两步：

1. 先从目录项中根据二分法快速确定出主键值为`20`的记录在`目录项3`中（因为 `12 < 20 < 209`），它对应的页是`页9`。
2. 再根据前边说的在页中查找记录的方式去`页9`中定位具体的记录。

至此，针对数据页做的简易目录就搞定了。**这个`目录`有一个别名，称为`索引`。**

#### （2）InnoDB中的索引方案

上述方案会存在两个问题

- `InnoDB`是使用页来作为管理存储空间的基本单位，也就是最多能保证`16KB`的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。
- 我们时常会对记录进行增删，假设我们把`页28`中的记录都删除了，`页28`也就没有存在的必要了，那意味着`目录项2`也就没有存在的必要了，这就需要把`目录项2`后的目录项都向前移动一下，这种牵一发而动全身的设计不是什么好主意。

所以，设计`InnoDB`的大叔们需要一种可以灵活管理所有`目录项`的方式。这里MySQL的亮点之处在于，他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为`目录项记录`。那`InnoDB`怎么区分一条记录是普通的`用户记录`还是`目录项记录`呢？用的`record_type`字段，各个取值代表的意思如下：

- `0`：普通的用户记录
- `1`：目录项记录
- `2`：最小记录
- `3`：最大记录

把前边使用到的目录项放到数据页中的样子就是这样：

![image-20240505153909131](assets/image-20240505153909131.png)

从图中可以看出来，**我们新分配了一个编号为`30`的页来专门存储`目录项记录`**。这里再次强调一遍`目录项记录`和普通的`用户记录`的不同点：

- `目录项记录`的`record_type`值是1，而普通用户记录的`record_type`值是0。
- `目录项记录`只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有`InnoDB`自己添加的隐藏列。
- 头信息中说过的`min_rec_mask`属性，只有在存储`目录项记录`的页中的主键值最小的`目录项记录`的`min_rec_mask`值为`1`，其他别的记录的`min_rec_mask`值都是`0`。

除了上述几点外，存储目录项纪录的数据页和普通的数据页这两者就没啥差别了，它们用的是一样的数据页，页的组成结构也是一样一样的（就是我们前边介绍过的7个部分），都会为主键值生成`Page Directory`（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。

现在以查找主键为`20`的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1. **先到存储`目录项记录`的页，也就是页`30`中通过二分法快速定位到对应目录项，因为`12 < 20 < 209`，所以定位到对应的记录所在的页就是`页9`。**
2. **再到存储用户记录的`页9`中根据二分法快速定位到主键值为`20`的用户记录。**

#### （3）B+树

如果表中的数据太多，以至于一个数据页不足以存放所有的`目录项记录`，该咋办呢，再多整一个存储`目录项记录`的页。 为了大家更好的理解新分配一个`目录项记录`页的过程，我们假设一个存储`目录项记录`的页最多只能存放4条`目录项记录`，所以如果此时我们再向上图中插入一条主键值为`320`的用户记录的话，那就需要分配一个新的存储`目录项记录`的页：

![image-20240505154833710](assets/image-20240505154833710.png)

所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为`20`的记录为例：

1. 确定`目录项记录`页。

   我们现在的存储`目录项记录`的页有两个，即`页30`和`页32`，又因为`页30`表示的目录项的主键值的范围是`[1, 320)`，`页32`表示的目录项的主键值不小于`320`，所以主键值为`20`的记录对应的目录项记录在`页30`中。

2. 通过`目录项记录`页确定用户记录真实所在的页。

   在一个存储`目录项记录`的页中通过主键值定位一条目录项记录的方式说过了，不赘述了。

3. 在真实存储用户记录的页中定位到具体的记录。

在这个查询步骤的第1步中我们需要定位存储`目录项记录`的页，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多存储`目录项记录`的页，那我们怎么根据主键值快速定位一个存储`目录项记录`的页呢？MySQL的做法是为这些存储`目录项记录`的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子

<img src="assets/image-20240505155124344.png" alt="image-20240505155124344" style="zoom:50%;" />

如图，我们生成了一个存储更高级目录项的`页33`，这个页中的两条记录分别代表`页30`和`页32`，如果用户记录的主键值在`[1, 320)`之间，则到`页30`中查找更详细的`目录项记录`，如果主键值不小于`320`的话，就到`页32`中查找更详细的`目录项记录`。随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：

<img src="assets/image-20240505155520828.png" alt="image-20240505155520828" style="zoom:50%;" />

这是一种组织数据的形式，或者说是一种数据结构，它的名称是`B+`树。

不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到`B+`树这个数据结构中了，所以我们也称这些数据页为`节点`。从图中可以看出来，**我们的实际用户记录其实都存放在B+树的最底层的节点上**，这些节点也被称为`叶子节点`或`叶节点`，其余用来存放`目录项`的节点称为`非叶子节点`或者`内节点`，其中`B+`树最上边的那个节点也称为`根节点`。

假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：

- 如果`B+`树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放`100`条记录。
- 如果`B+`树有2层，最多能存放`1000×100=100000`条记录。
- 如果`B+`树有3层，最多能存放`1000×1000×100=100000000`条记录。
- 如果`B+`树有4层，最多能存放`1000×1000×1000×100=100000000000`条记录。

`100000000000`条记录已经是一个很大的数了？所以一般情况下，我们用到的`B+`树都不会超过4层，**那我们通过主键值去查找某条记录最多只需要做4个页面内的查找**（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的`Page Directory`（页目录），所以在页面内也可以通过二分法实现快速定位记录。

### 3. 索引类型

#### （1）聚簇索引

上面介绍的`B+`树有两个特点：

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
   - 页内的记录是按照主键的大小顺序排成一个单向链表。
   - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
   - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。
2. `B+`树的叶子节点存储的是完整的用户记录。

我们把具有这两种特性的`B+`树称为`聚簇索引`，**所有完整的用户记录都存放在这个`聚簇索引`的叶子节点处**，这个非常重要，后面二级索引会对聚簇索引进行回表查询。这种`聚簇索引`并不需要我们在`MySQL`语句中显式的使用`INDEX`语句去创建，`InnoDB`存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在`InnoDB`存储引擎中，`聚簇索引`就是数据的存储方式（所有的用户记录都存储在了`叶子节点`），也就是所谓的**索引即数据，数据即索引**。

#### （2）二级索引

上边介绍的`聚簇索引`只能在搜索条件是主键值时才能发挥作用，因为`B+`树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该咋办呢？

**我们可以多建几棵`B+`树，不同的`B+`树中的数据采用不同的排序规则**。比方说我们用`c2`列的大小作为数据页、页中记录的排序规则，再建一棵`B+`树，效果如下图所示：

![image-20240505193053644](assets/image-20240505193053644.png)

这个`B+`树与上边介绍的聚簇索引有几处不同：

- **使用记录`c2`列的大小进行记录和页的排序**，这包括三个方面的含义：
  - 页内的记录是按照`c2`列的大小顺序排成一个单向链表。
  - 各个存放用户记录的页也是根据页中记录的`c2`列大小顺序排成一个双向链表。
  - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的`c2`列大小顺序排成一个双向链表。
- **`B+`树的叶子节点存储的并不是完整的用户记录，而只是`c2列+主键`这两个列的值。**
- 目录项记录中不再是`主键+页号`的搭配，而变成了`c2列+页号`的搭配。

以查找`c2`列的值为`4`的记录为例，查找过程如下：

1. 确定`目录项记录`页

   根据`根页面`，也就是`页44`，可以快速定位到`目录项记录`所在的页为`页42`，注意看页42的数据（因为`2 < 4 < 9`）。

2. 通过`目录项记录`页确定用户记录真实所在的页。

   在`页42`中可以快速定位到实际存储用户记录的页，但是由于`c2`列并没有唯一性约束，所以`c2`列值为`4`的记录可能分布在多个数据页中，又因为`2 < 4 ≤ 4`，所以确定实际存储用户记录的页在`页34`和`页35`中。

3. 在真实存储用户记录的页中定位到具体的记录。

   到`页34`和`页35`中定位到具体的记录。

4. 但是这个`B+`树的叶子节点中的记录只存储了`c2`和`c1`（也就是`主键`）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。

**我们根据这个以`c2`列大小排序的`B+`树只能确定我们要查找记录的主键值，所以如果我们想根据`c2`列的值查找到完整的用户记录的话，仍然需要到`聚簇索引`中再查一遍，这个过程也被称为`回表`**。也就是根据`c2`列的值查询一条完整的用户记录需要使用到`2`棵`B+`树！

为什么我们还需要一次`回表`操作呢？直接把完整的用户记录放到`叶子节点`不就好了么？如果把完整的用户记录放到`叶子节点`是可以不用`回表`，但是太占地方了～相当于每建立一棵`B+`树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。

#### （3）联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让`B+`树按照`c2`和`c3`列的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照`c2`列进行排序。
- 在记录的`c2`列相同的情况下，采用`c3`列进行排序

为`c2`和`c3`列建立的索引的示意图如下：

<img src="assets/image-20240505195742480.png" alt="image-20240505195742480" style="zoom:50%;" />

如图所示，我们需要注意一下几点：

- 每条`目录项记录`都由`c2`、`c3`、`页号`这三个部分组成，各条记录先按照`c2`列的值进行排序，如果记录的`c2`列相同，则按照`c3`列的值进行排序。
- `B+`树叶子节点处的用户记录由`c2`、`c3`和主键`c1`列组成。

千万要注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：

- 建立`联合索引`只会建立如上图一样的1棵`B+`树。
- 为c2和c3列分别建立索引会分别以`c2`和`c3`列的大小为排序规则建立2棵`B+`树。

### 4. 知识总结

- 每个索引都对应一棵`B+`树，`B+`树分为好多层，最下边一层是叶子节点，其余的是内节点。所有`用户记录`都存储在`B+`树的叶子节点，所有`目录项记录`都存储在内节点。
- `InnoDB`存储引擎会自动为主键（如果没有它会自动帮我们添加）建立`聚簇索引`，聚簇索引的叶子节点包含完整的用户记录。
- 我们可以为自己感兴趣的列建立`二级索引`，`二级索引`的叶子节点包含的用户记录由`索引列 + 主键`组成，所以如果想通过`二级索引`来查找完整的用户记录的话，需要通过`回表`操作，也就是在通过`二级索引`找到主键值之后再到`聚簇索引`中查找完整的用户记录。
- `B+`树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是`联合索引`的话，则页面和记录先按照`联合索引`前边的列排序，如果该列值相同，再按照`联合索引`后边的列排序。
- 通过索引查找记录是从`B+`树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了`Page Directory`（页目录），所以在这些页面中的查找非常快。

## 五、MySQL的数据目录

### 1. 简介

MySQL服务器程序在启动时会到文件系统的某个目录下加载一些文件，之后在运行过程中产生的数据也都会存储到这个目录下的某些文件中，这个目录就称为`数据目录`。可以通过如下命令来确定mysql的`数据目录`的路径

```mysql
mysql> SHOW VARIABLES LIKE 'datadir';
+---------------+-----------------------+
| Variable_name | Value                 |
+---------------+-----------------------+
| datadir       | /usr/local/var/mysql/ |
+---------------+-----------------------+
1 row in set (0.00 sec)
```

### 2. 数据库在文件夹中的表示

当我们使用`CREATE DATABASE 数据库名`语句创建一个数据库的时候，`MySQL`会帮我们做这两件事在数据目录下创建一个和数据库名同名的子目录（或者说是文件夹）。

```bash
192:data root# ls -la
total 183632
-rw-r-----    1 _mysql  _mysql    196608  5  3 16:14 #ib_16384_0.dblwr
-rw-r-----    1 _mysql  _mysql   8585216 12 25 16:45 #ib_16384_1.dblwr
drwxr-x---   34 _mysql  _mysql      1088  5  3 13:18 #innodb_redo
drwxr-x---   12 _mysql  _mysql       384  5  3 13:18 #innodb_temp
drwxr-x---   57 _mysql  _mysql      1824  5  3 13:18 .
drwxr-xr-x   13 root    wheel        416 12 25 16:45 ..
drwxr-x---    8 _mysql  _mysql       256  5  2 09:14 auth
-rw-r-----    1 _mysql  _mysql        56 12 25 16:45 auto.cnf
-rw-r-----    1 _mysql  _mysql       180  4  3 18:25 binlog.000052
-rw-r-----    1 _mysql  _mysql       180  4  6 21:41 binlog.000053
-rw-r-----    1 _mysql  _mysql       448  5  3 13:18 binlog.index
-rw-------    1 _mysql  _mysql      1705 12 25 16:45 ca-key.pem
-rw-r--r--    1 _mysql  _mysql      1108 12 25 16:45 ca.pem
-rw-r--r--    1 _mysql  _mysql      1108 12 25 16:45 client-cert.pem
-rw-------    1 _mysql  _mysql      1705 12 25 16:45 client-key.pem
-rw-r-----    1 _mysql  _mysql      3975  5  2 21:20 ib_buffer_pool
-rw-r-----    1 _mysql  _mysql  12582912  5  3 16:12 ibdata1
-rw-r-----    1 _mysql  _mysql  12582912  5  3 13:18 ibtmp1
drwxr-x---    8 _mysql  _mysql       256 12 25 16:45 mysql
-rw-r-----    1 _mysql  _mysql  26214400  5  3 16:12 mysql.ibd
-rw-r-----    1 _mysql  _mysql    137127  5  3 13:18 mysqld.local.err
-rw-r-----    1 _mysql  _mysql         4  5  3 13:18 mysqld.local.pid
drwxr-x---    5 _mysql  _mysql       160  2 21 16:49 oauth2
drwxr-x---  114 _mysql  _mysql      3648 12 25 16:45 performance_schema
-rw-------    1 _mysql  _mysql      1705 12 25 16:45 private_key.pem
-rw-r--r--    1 _mysql  _mysql       452 12 25 16:45 public_key.pem
-rw-r--r--    1 _mysql  _mysql      1108 12 25 16:45 server-cert.pem
-rw-------    1 _mysql  _mysql      1705 12 25 16:45 server-key.pem
drwxr-x---    3 _mysql  _mysql        96 12 25 16:45 sys
-rw-r-----    1 _mysql  _mysql  16777216  5  3 16:14 undo_001
-rw-r-----    1 _mysql  _mysql  16777216  5  3 16:14 undo_002
```

### 3. 表在文件系统中的表示

表在文件系统中是以ibd形式存在的

```bash
192:auth root# ls -la
total 1440
-rw-r-----   1 _mysql  _mysql  131072  4 22 23:34 file_list_information.ibd
-rw-r-----   1 _mysql  _mysql  114688  5  2 08:46 hero.ibd
-rw-r-----   1 _mysql  _mysql  114688  5  3 16:12 page_demo.ibd
-rw-r-----   1 _mysql  _mysql  114688  4 26 21:13 record_format_demo.ibd
-rw-r-----   1 _mysql  _mysql  131072  4 22 23:34 review_information.ibd
-rw-r-----   1 _mysql  _mysql  131072  4 21 10:25 user.ibd
```

## 二十、事务

### 1. ACID

#### （1）原子性

现实世界中转账操作是一个不可分割的操作，也就是说要么压根儿就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况，这种规则称之为`原子性`。数据库中的一条操作可能被分解成若干个步骤，比**如先修改缓存页，之后再刷新到磁盘等**，而且任何一个可能的时间都可能发生意想不到的错误，可能是数据库本身的错误，或者是操作系统错误，甚至是直接断电之类的，而使操作执行不下去。为了保证在数据库世界中某些操作的原子性，需要保证如果在执行操作的过程中发生了错误，把已经做了的操作恢复成没执行之前的样子。

这个特性可以说是事务最重要的特性。

#### （2）隔离性

现实世界中的两次状态转换应该是互不影响的，比如说张三向李四同时进行的两次金额为5元的转账（假设可以在两个ATM机上同时操作）。那么最后张三的账户里肯定会少10元，李四的账户里肯定多了10元。但是到对应的数据库世界中，事情又变的复杂了一些。为了简化问题，我们粗略的假设张三向李四转账5元的过程是由下边几个步骤组成的：

- 步骤一：读取张三账户的余额到变量A中，这一步骤简写为`read(A)`。
- 步骤二：将张三账户的余额减去转账金额，这一步骤简写为`A = A - 5`。
- 步骤三：将张三账户修改过的余额写到磁盘里，这一步骤简写为`write(A)`。
- 步骤四：读取李四账户的余额到变量B，这一步骤简写为`read(B)`。
- 步骤五：将李四账户的余额加上转账金额，这一步骤简写为`B = B + 5`。
- 步骤六：将李四账户修改过的余额写到磁盘里，这一步骤简写为`write(B)`。

我们将张三向李四同时进行的两次转账操作分别称为`T1`和`T2`，在现实世界中`T1`和`T2`是应该没有关系的，可以先执行完`T1`，再执行`T2`，或者先执行完`T2`，再执行`T1`，对应的数据库操作就像这样：

<img src="assets/image-20240501153944925.png" alt="image-20240501153944925" style="zoom:50%;" />

但是真实的数据库中`T1`和`T2`的操作可能交替执行，比如这样

<img src="assets/image-20240501154050270.png" alt="image-20240501154050270" style="zoom:50%;" />

如果按照上图中的执行顺序来进行两次转账的话，最终张三的账户里还剩`6`元钱，相当于只扣了5元钱，但是李四的账户里却成了`12`元钱，相当于多了10元钱，这银行岂不是要亏死了？

现实世界中状态转换对应的某些数据库操作来说，不仅要保证这些操作以`原子性`的方式执行完成，而且要保证其它的状态转换不会影响到本次状态转换，这个规则被称之为`隔离性`。这时就需要采取一些措施来让访问相同数据（上例中的A账户和B账户）的不同状态转换（上例中的`T1`和`T2`）对应的数据库操作的执行顺序有一定规律。

#### （3）持久性

比较好理解，`持久性`意味着数据库操作所修改的数据，不论之后发生了什么事故，都应该在磁盘上保留下来，这个规则被称为`持久性`。

#### （4）一致性

一致性比较难理解，参考https://www.zhihu.com/question/31346392/answer/290643186

**AID都是手段，C是目的**，一致性是指：数据库状态与真实业务状态相一致。为了达成一致性，需要在事务中保证原子性、隔离性和持久性。做个比喻事务就好比一个保镖，我们提到事务就会说ACID，而我们提到保镖会说强壮、好功夫、踏实、安全，这里强壮，好功夫和踏实都是保镖自己的特征，而安全则是我们聘请保镖的目的。

数据库本身能为我们保证一部分一致性需求（保证现实世界的约束永远有效）。`MySQL`数据库可以为表建立主键、唯一索引、外键、声明某个列为`NOT NULL`来拒绝`NULL`值的插入。比如说当我们对某个列建立唯一索引时，如果插入某条记录时该列的值重复了，那么`MySQL`就会报错并且拒绝插入。

### 2. 事务的概念

**把需要保证`原子性`、`隔离性`、`一致性`和`持久性`的一个或多个数据库操作称之为一个`事务`**。`事务`是一个抽象的概念，它其实对应着一个或多个数据库操作。数据库执行的不同阶段，把`事务`大致上划分成了这么几个状态：

- 活动的（active）

  事务对应的数据库操作正在执行过程中时，我们就说该事务处在`活动的`状态。

- 部分提交的（partially committed）

  当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在`部分提交的`状态。

- 失败的（failed）

  当事务处在`活动的`或者`部分提交的`状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在`失败的`状态。

- 中止的（aborted）

  如果事务执行了半截而变为`失败的`状态，就需要把已经修改的数据进行撤销，这个撤销的过程称之为`回滚`。当`回滚`操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了`中止的`状态。

- 提交的（committed）

  当一个处在`部分提交的`状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了`提交的`状态。

<img src="assets/image-20240501161133862.png" alt="image-20240501161133862" style="zoom:50%;" />

从图中可以看出，只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。

>事务的英文是transaction，英文直译就是交易，买卖的意思，交易就是买的人付钱，卖的人交货，不能付了钱不交货，交了货不付钱，所以交易本身就是一种不可分割的操作。国内把transaction翻译成了事务，其实并不准确。

### 3. 事务的语法

**`事务`的本质其实只是一系列数据库操作，只不过这些数据库操作符合`ACID`特性而已**，那么`MySQL`中如何将某些操作放到一个事务里去执行呢？

#### （1）开启事务

可以使用下边两种语句之一来开启一个事务：

- `BEGIN [WORK];`

  `BEGIN`语句代表开启一个事务，后边的单词`WORK`可有可无。开启事务后，就可以继续写若干条语句，这些语句都属于刚刚开启的这个事务。

- `START TRANSACTION;`

  `START TRANSACTION`语句和`BEGIN`语句有着相同的功效，都标志着开启一个事务，不过比`BEGIN`语句牛逼一点儿的是，可以在`START TRANSACTION`语句后边跟随几个`修饰符`，例如`READ ONLY`

#### （2）提交事务

开启事务之后就可以继续写需要放到该事务中的语句了，当最后一条语句写完了之后，我们就可以提交该事务了，提交的语句也很简单：`COMMIT [WORK]`。下面是一个完整的开启提交事务的例子

```mysql
mysql> BEGIN;
Query OK, 0 rows affected (0.00 sec)

mysql> UPDATE account SET balance = balance - 10 WHERE id = 1;
Query OK, 1 row affected (0.02 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> UPDATE account SET balance = balance + 10 WHERE id = 2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> COMMIT;
Query OK, 0 rows affected (0.00 sec)
```

#### （3）手动中止事务

如果我们写了几条语句之后发现上边的某条语句写错了，我们可以手动的使用下边这个语句来将数据库恢复到事务执行之前的样子：`ROLLBACK [WORK]`

```mysql
mysql> BEGIN;
Query OK, 0 rows affected (0.00 sec)

mysql> UPDATE account SET balance = balance - 10 WHERE id = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> UPDATE account SET balance = balance + 1 WHERE id = 2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> ROLLBACK;
Query OK, 0 rows affected (0.00 sec)
```

#### （4）自动提交

`MySQL`中有一个系统变量`autocommit`：

```bash
mysql> SHOW VARIABLES LIKE 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.01 sec)
```

可以看到它的默认值为`ON`，也就是说默认情况下，如果我们不显式的使用`START TRANSACTION`或者`BEGIN`语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的`自动提交`。假如我们在张三向李四转账10元时不以`START TRANSACTION`或者`BEGIN`语句显式的开启一个事务，那么下边这两条语句就相当于放到两个独立的事务中去执行：

```mysql
UPDATE account SET balance = balance - 10 WHERE id = 1;
UPDATE account SET balance = balance + 10 WHERE id = 2;
```

> 这里有个之前一直没有搞懂的问题，既然DDL语句会自动提交事务，我们在平时的业务中还需要去显式的开启事务吗？我的答案是，**如果只是一个单独的语句，我们没必要去开启事务。但是对于一个类似于银行转账的事务，显然我们需要去开启一个事务**，因为如果只转出成功而没有转入成功，显然对转账方是不公平的。

如果想关闭这种`自动提交`的功能，可以使用下边两种方法之一：

- 显式的的使用`START TRANSACTION`或者`BEGIN`语句开启一个事务。
- 把系统变量`autocommit`的值设置为`OFF`

```mysql
SET autocommit = OFF;
```

#### （5）隐式提交

当我们使用`START TRANSACTION`或者`BEGIN`语句开启了一个事务，或者把系统变量`autocommit`的值设置为`OFF`时，事务就不会进行`自动提交`，但是**如果我们输入了某些语句之后就会`悄悄的`提交掉，就像我们输入了`COMMIT`语句了一样**，这种因为某些特殊的语句而导致事务提交的情况称为`隐式提交`，这些会导致事务隐式提交的语句包括：

- 定义或修改数据库对象的数据定义语言（Data definition language，缩写为：`DDL`）。

所谓的数据库对象，指的就是`数据库`、`表`、`视图`、`存储过程`等等这些东西。当我们使用`CREATE`、`ALTER`、`DROP`等语句去修改这些所谓的数据库对象时，就会隐式的提交前边语句所属于的事务，就像这样：

> ⚠️注意看这个例子

```mysql
BEGIN;

SELECT ... # 事务中的一条语句
UPDATE ... # 事务中的一条语句
... # 事务中的其它语句

CREATE TABLE ... # 此语句会隐式的提交前边语句所属于的事务
```

- 当我们使用`ALTER USER`、`CREATE USER`、`DROP USER`、`GRANT`、`RENAME USER`、`REVOKE`、`SET PASSWORD`等语句时也会隐式的提交前边语句所属于的事务。

## 二十一、事务的隔离级别和MVCC

### 1. 事务隔离级别

`MySQL`是一个客户端／服务器架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，**每个客户端与服务器连接上之后，就可以称之为一个会话（`Session`）**。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。前面说过事务有一个称之为`隔离性`的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样子的话对性能影响太大，我们既想保持事务的`隔离性`，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，鱼和熊掌不可得兼，舍一部分`隔离性`而取性能者也。

### 2. 并发事务遇到的问题

我们先看一下访问相同数据的事务在不保证串行执行（也就是执行完一个再执行另一个）的情况下可能会出现哪些问题：

#### （1）脏写

**一个事务修改了另一个未提交事务修改过的数据。**

<img src="assets/image-20240501195425493.png" alt="image-20240501195425493" style="zoom:50%;" />

> 注意：由于脏写这个问题太严重了，现在MySQL不论是哪种隔离级别，都不允许脏写的情况发生，因此我们会发现按照作者这个操作，在执行第4个操作时会卡住。

如上图，`Session A`和`Session B`各开启了一个事务，`Session B`中的事务先将`number`列为`1`的记录的`name`列更新为`'关羽'`，然后`Session A`中的事务接着又把这条`number`列为`1`的记录的`name`列更新为`张飞`。如果之后`Session B`中的事务进行了回滚，那么`Session A`中的更新也将不复存在，这种现象就称之为`脏写`。这时`Session A`中的事务就很懵逼，我明明把数据更新了，最后也提交事务了，怎么到最后说自己啥也没干呢

#### （2）脏读

**一个事务读到了另一个未提交事务修改过的数据。**

> 先设置隔离级别为【未提交读】，SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

<img src="assets/image-20240501195750527.png" alt="image-20240501195750527" style="zoom:50%;" />

如上图，`Session A`和`Session B`各开启了一个事务，`Session B`中的事务先将`number`列为`1`的记录的`name`列更新为`'关羽'`，然后`Session A`中的事务再去查询这条`number`为`1`的记录，如果读到列`name`的值为`'关羽'`，而`Session B`中的事务稍后进行了回滚，那么`Session A`中的事务相当于读到了一个不存在的数据，这种现象就称之为`脏读`。

#### （3）不可重复读

如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。

> 先设置隔离级别为【已提交读】，SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;

<img src="assets/image-20240502083839602.png" alt="image-20240502083839602" style="zoom:50%;" />

如上图，我们在`Session B`中提交了几个隐式事务（注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了`number`列为`1`的记录的列`name`的值，每次事务提交之后，如果`Session A`中的事务都可以查看到最新的值，这种现象也被称之为`不可重复读`。

> 理论上来说，开启了一个事务，相当于躲在防空洞里，外面世界如何变化，和我无关

#### （4）幻读

如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。

> 先设置隔离级别为【可重复读】，SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;

<img src="assets/image-20240502084501212.png" alt="image-20240502084501212" style="zoom:50%;" />

如上图，`Session A`中的事务先根据条件`number > 0`这个条件查询表`hero`，得到了`name`列值为`'刘备'`的记录；之后`Session B`中提交了一个隐式事务，该事务向表`hero`中插入了一条新记录；之后`Session A`中的事务再根据相同的条件`number > 0`查询表`hero`，得到的结果集中包含`Session B`中的事务新插入的那条记录，这种现象也被称之为`幻读`。

> 注意⚠️：MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的，也就是这个例子并不能复现出来。

### 3. 事务中的隔离级别

#### （1）隔离级别语法

查看事务隔离级别： 

```mysql
SHOW VARIABLES LIKE 'transaction_isolation';
```

设置事务隔离级别：

```mysql
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;
```

#### （2）四种隔离级别

- `READ UNCOMMITTED`：未提交读。
- `READ COMMITTED`：已提交读。
- `REPEATABLE READ`：可重复读。MySQL默认的隔离级别。
- `SERIALIZABLE`：可串行化。

<img src="assets/image-20240501210551135.png" alt="image-20240501210551135" style="zoom:50%;" />

给这些问题按照严重性来排一下序：**脏写 > 脏读 > 不可重复读 > 幻读**。上边所说的舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生。

### 4. MVCC

## 二十五、锁

### 1. 并发事务的问题

并发事务访问相同记录的情况大致可以划分为3种（读-写和写-读）是同一种：

#### （1）读-读

即并发事务相继读取相同的记录，读取操作本身不会对记录有一毛钱影响，并不会引起什么问题，所以允许这种情况的发生。

#### （2）写-写

前边说过，在这种情况下会发生`脏写`的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过`锁`来实现的。

这个所谓的`锁`其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有`锁结构`和记录进行关联的，当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的`锁结构`，当没有的时候就会在内存中生成一个`锁结构`与之关联。比方说事务`T1`要对这条记录做改动，就需要生成一个`锁结构`与之关联。

<img src="assets/image-20240502153917080.png" alt="image-20240502153917080" style="zoom:50%;" />



在`锁结构`里有很多信息，为了简化理解，我们现在只把两个比较重要的属性拿了出来：

- `trx信息`：代表这个锁结构是哪个事务生成的。
- `is_waiting`：代表当前事务是否在等待。

当事务`T1`改动了这条记录后，就生成了一个`锁结构`与该记录关联，之前没有别的事务为这条记录加锁，所以`is_waiting`属性就是`false`，这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操作了。

在事务`T1`提交之前，另一个事务`T2`也想对该记录做改动，那么先去看看有没有`锁结构`与这条记录关联，发现有一个`锁结构`与之关联后，然后也生成了一个`锁结构`与这条记录关联，不过`锁结构`的`is_waiting`属性值为`true`，表示当前事务需要等待，我们把这个场景就称之为获取锁失败，或者加锁失败，或者没有成功的获取到锁，画个图表示就是这样。

<img src="assets/image-20240502154152632.png" alt="image-20240502154152632" style="zoom:50%;" />

在事务`T1`提交之后，就会把该事务生成的`锁结构`释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务`T2`还在等待获取锁，所以把事务`T2`对应的锁结构的`is_waiting`属性设置为`false`，然后把该事务对应的线程唤醒，让它继续执行，此时事务`T2`就算获取到锁了。效果图就是这样：

<img src="assets/image-20240502154645391.png" alt="image-20240502154645391" style="zoom:50%;" />

#### （3）读-写

也就是一个事务进行读取操作，另一个进行改动操作。前边说过，这种情况下可能发生`脏读`、`不可重复读`、`幻读`的问题。



