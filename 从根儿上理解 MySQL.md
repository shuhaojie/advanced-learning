# 从根儿上理解MySQL

- 选自<https://juejin.cn/book/6844733769996304392/>

## 一、预备知识

### 1. 可执行文件

- MacOS安装目录：`/usr/local/mysql/bin`，里面有非常多的可执行文件，启动客户端程序和服务端程序都可以通过执行可执行文件来完成。

```bash
➜  bin ls -la
-rwxr-xr-x   1 root  wheel    8867936  7  7  2022 mysql  # 启动客户端
-rwxr-xr-x   1 root  wheel       5002  7  7  2022 mysql_config
-rwxr-xr-x   1 root  wheel    9235680  7  7  2022 mysqlbinlog
-rwxr-xr-x   1 root  wheel    8498064  7  7  2022 mysqlcheck
-rwxr-xr-x   1 root  wheel   74288112  7  7  2022 mysqld  # 启动服务端
...
```

### 2. 客户端与服务端连接

- MySQL采用的是TCP协议，服务端默认监听3306端口，因此客户端需要去连接到3306端口

- **如果我们的服务器进程和客户端进程都运行在同一台操作系统为类`Unix`的机器上的话**，我们可以使用`Unix域套接字文件`来进行进程间通信，连接方式`mysql --socket=/tmp/mysql.sock -u {username} -p`。如果客户端程序和服务器程序不运行在一台计算机上，我们还可以采用使用了`SSL`（安全套接字）的网络连接进行通信，来保证数据传输的安全性。

> 注：每个操作系统对应的socket文件路径不一样，具体socket文件位置路径，可以通过`mysqladmin -p -u {username} variables`命令来查看，这个命令非常神奇

- 使用MySQL时，**需要首先启动服务端，再启动客户端**，然后在客户端程序中输入一些命令语句作为请求发送到服务器程序

### 3. 服务端处理客户端请求

客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）

<img src="assets/image-20230506231125514.png" alt="image-20230506231125514" style="zoom:80%;" />

#### （1）连接管理

每当有一个客户端进程连接到服务器进程时，MySQL服务器进程都**会创建一个线程**来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并**不会立即把与该客户端交互的线程销毁掉**，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求，`MySQL`服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理。

可以通过`SHOW PROCESSLIST`来查看客户端连接情况

```mysql
mysql> SHOW PROCESSLIST;
+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+
| Id | User            | Host            | db   | Command | Time  | State                  | Info             |
+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+
|  5 | event_scheduler | localhost       | NULL | Daemon  | 13829 | Waiting on empty queue | NULL             |
|  8 | root            | localhost       | auth | Query   |     0 | init                   | SHOW PROCESSLIST |
| 10 | root            | localhost:61671 | auth | Sleep   |  9008 |                        | NULL             |
| 15 | root            | localhost       | NULL | Sleep   |   763 |                        | NULL             |
+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+
4 rows in set, 1 warning (0.01 sec)
```

这里

- User：代表连接的用户
- Time：代表连接的时间，单位是秒
- Command：代表命令，"Sleep" 状态**表示连接处于空闲状态，即客户端当前没有活动**。当我们创建一个连接，而没有关闭这个连接时，其状态就是Sleep。

```python
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://root:root@127.0.0.1:3306/auth'
app.config['SQLALCHEMY_DATABASE_URI'] = SQLALCHEMY_DATABASE_URI
db = SQLAlchemy(app)
session = db.session

@app.route('/post_file_sync', methods=['POST'])
def post_file_sync():
    data = request.json
    session.query(User).filter(User.email == data["email"]).delete()
    session.commit()
    session.close()
    return jsonify({"message": "success"}), 200
```

在上面代码中

- 程序最后的`session.close()`命令，也**并不会去关闭MySQL服务器上的连接**。在SQLAlchemy中，session，engine和connection的具体区别，可以参考MySQL的文档，有非常详细的说明。

  > sesssion就好比你在餐厅，客人点了一份汉堡，你不会立刻去做，而是把它写在订单上，然后等到一桌订单都写好了，才会开始制作。session就像是这张订单，它可以暂存你的操作，然后一次性提交。

- 如果想关闭MySQL服务器上的连接，可以采用如下的形式

```python
engine_container = db.get_engine(app)
session.close()  # 关闭session
engine_container.dispose() # 关闭数据库连接
```

#### （2）解析与优化

MySQL服务器获得文本形式的请求后，还要经过九九八十一难的处理，其中的几个比较重要的部分分别是`查询缓存`、`语法解析`和`查询优化`

##### a. 查询缓存

如果我问你`9+8×16-3×2×17`的值是多少，我们计算得到结果`35`，如果我再问你一遍`9+8×16-3×2×17`的值是多少，由于刚刚已经算过了，直接说答案就好了。`MySQL`服务器程序处理查询请求的过程也是这样，会把刚刚处理过的查询请求和结果`缓存`起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了。

不过既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，**如对该表使用了`INSERT`、 `UPDATE`、`DELETE`等语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除**

> 由于维护缓存需要造成一些开销，从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。

##### b. 语法解析

如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以`MySQL`服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到`MySQL`服务器内部使用的一些数据结构上来。

##### c. 查询优化

语法解析之后，服务器程序获得到了需要的信息，但我们写的`MySQL`语句执行起来效率可能并不是很高，`MySQL`的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接等。**优化的结果就是生成一个执行计划**，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的，我们可以使用`EXPLAIN`语句来查看某个语句的执行计划。

```bash
mysql> explain select * from user;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

##### d. 存储引擎

**`MySQL`服务器把数据的存储和提取操作都封装到了一个叫`存储引擎`的模块里**，知道`表`是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是`存储引擎`负责的事情。

### 4. 启动选项

- 在Mysql中，可以修改很多选项，例如如果我们在启动服务器程序的时候就禁止各客户端使用`TCP/IP`网络进行通信，可以在启动服务器程序的命令行里添加`skip-networking`启动选项，就像这样：

  ```mysql
  mysqld --skip-networking
  ```

  按照上述命令启动服务器程序后，如果我们再使用`mysql`来启动客户端程序时，再把服务器主机名指定为`127.0.0.1`（IP地址的形式）的话会显示连接失败

- 也可以把这些启动选项写在配置文件中，这样做的好处是不必每次启动mysql服务，都再次把配置再写一遍，

  在unix系统中，**mysql按照如下顺序去找配置，优先读前面路径的配置**。

  | 路径名                | 备注                                 |
  | --------------------- | ------------------------------------ |
  | `/etc/my.cnf`         |                                      |
  | `/etc/mysql/my.cnf`   |                                      |
  | `SYSCONFDIR/my.cnf`   |                                      |
  | `$MYSQL_HOME/my.cnf`  | 特定于服务器的选项（仅限服务器）     |
  | `defaults-extra-file` | 命令行指定的额外配置文件路径         |
  | `~/.my.cnf`           | 用户特定选项                         |
  | `~/.mylogin.cnf`      | 用户特定的登录路径选项（仅限客户端） |

  例如我们可以手动创建一个配置，`/etc/my.cnf`

  ```bash
  [mysqld]
  port = 3306
  character_set_server = utf8mb4
  log_error = /var/log/mysql/error.log
  slow_query_log = 1
  slow_query_log_file = /var/log/mysql/slow-query.log
  long_query_time = 2
  key_buffer_size = 16M
  innodb_buffer_pool_size = 128M
  max_connections = 100
  bind-address = 127.0.0.1
  ```
  
  服务端启动`mysqld`的时候，就会去读这个配置

### 5. 系统变量

`MySQL`服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为`MySQL`系统变量，比如允许同时连入的客户端数量用系统变量`max_connections`表示。

### （1）查看系统变量

可以使用下列命令查看`MySQL`服务器程序支持的系统变量以及它们的当前值：

```mysql
mysql> SHOW VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
1 row in set (0.01 sec)

mysql> SHOW VARIABLES like 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 151   |
+-----------------+-------+
1 row in set (0.00 sec)
```

### （2）设置系统变量

可以通过两种方式来来进行设置。

1. 通过命令行添加启动选项

```mysql
mysqld --default-storage-engine=MyISAM --max-connections=10
```

2. 通过配置文件添加启动选项

```bash
[server]
default-storage-engine=MyISAM
max-connections=10
```

当使用上边两种方式中的任意一种启动服务器程序后，我们再来查看一下系统变量的值：

```bash
mysql> SHOW VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | MyISAM |
+------------------------+--------+
1 row in set (0.00 sec)

mysql> SHOW VARIABLES LIKE 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 10    |
+-----------------+-------+
1 row in set (0.00 sec)
```

### （3）变量范围

变量范围有两种

- `GLOBAL`：全局变量，影响服务器的整体操作。
- `SESSION`：会话变量，影响某个客户端连接的操作。（注：`SESSION`有个别名叫`LOCAL`）

服务器启动时，会将每个【全局变量】初始化为其默认值，然后服务器还为每个连接的客户端维护一组【会话变量】，客户端的【会话变量】在连接时使用相应全局变量的当前值初始化。以`default_storage_engine`举例，在服务器启动时会初始化一个名为`default_storage_engine`，作用范围为`GLOBAL`的系统变量。之后每当有一个客户端连接到该服务器时，服务器都会单独为该客户端分配一个名为`default_storage_engine`，作用范围为`SESSION`的系统变量，该作用范围为`SESSION`的系统变量值按照当前作用范围为`GLOBAL`的同名系统变量值进行初始化。

可以通过如下方式，来设置全局变量/会话变量。

```mysql
SET [GLOBAL|SESSION] 系统变量名 = 值;
SET [@@(GLOBAL|SESSION).]var_name = XXX;
```

如果我们想在服务器运行过程中把作用范围为`GLOBAL`的系统变量`default_storage_engine`的值修改为`MyISAM`，也就是想让之后新连接到服务器的客户端都用`MyISAM`作为默认的存储引擎，那我们可以选择下边两条语句中的任意一条来进行设置

```mysql
# 方式一
SET GLOBAL default_storage_engine = MyISAM;
# 方式二
SET @@GLOBAL.default_storage_engine = MyISAM;
```

如果只想对本客户端生效，也可以选择下边三条语句中的任意一条来进行设置：

```mysql
# 方式一
SET SESSION default_storage_engine = MyISAM;
# 方式二
SET @@SESSION.default_storage_engine = MyISAM;
# 方式三
SET default_storage_engine = MyISAM;
```

既然`系统变量`有`作用范围`之分，那我们的`SHOW VARIABLES`语句查看的是什么`作用范围`的`系统变量`呢？

答：默认查看的是`SESSION`作用范围的系统变量。

下面是一个完整的示例，来理解这个

```mysql
mysql> SHOW SESSION VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
1 row in set (0.00 sec)

mysql> SHOW GLOBAL VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
1 row in set (0.00 sec)

mysql> SET SESSION default_storage_engine = MyISAM;
Query OK, 0 rows affected (0.00 sec)

mysql> SHOW SESSION VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | MyISAM |
+------------------------+--------+
1 row in set (0.00 sec)

mysql> SHOW GLOBAL VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
1 row in set (0.00 sec)
```

> 在 MySQL 中，使用 `SET GLOBAL` 命令设置全局变量时并不会立即生效，因为它仅影响新启动的会话，而不会影响当前正在运行的会话。

### （4）状态变量

为了让我们更好的了解服务器程序的运行情况，`MySQL`服务器程序中维护了好多关于程序运行状态的变量，它们被称为`状态变量`。比方说`Threads_connected`表示当前有多少客户端与服务器建立了连接。

```mysql
mysql> SHOW STATUS LIKE 'thread%';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_cached    | 0     |
| Threads_connected | 1     |
| Threads_created   | 1     |
| Threads_running   | 1     |
+-------------------+-------+
4 rows in set (0.00 sec)
```

## 二、InnoDB行格式

### 1. 行格式简介

我们平时是以记录为单位来向表中插入数据的，**这些记录在磁盘上的存放方式也被称为`行格式`**。目前存在四种行格式，分别是`Compact`、`Redundant`、`Dynamic`和`Compressed`，默认是Compact。

```mysql
mysql> CREATE TABLE record_format_demo (
         c1 VARCHAR(10),
         c2 VARCHAR(10) NOT NULL,
         c3 CHAR(10),
         c4 VARCHAR(10)
     ) CHARSET=ascii ROW_FORMAT=COMPACT;
mysql> INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);
```

### 2. Compact行格式

<img src="assets/image-20240426211522504.png" alt="image-20240426211522504" style="zoom:50%;" />

从图中可以看出来，一条完整的记录其实可以被分为`记录的额外信息`和`记录的真实数据`两大部分，下边我们详细看一下这两部分的组成。

#### （1）变长字段长度列表

MySQL支持一些变长的数据类型，比如VARCHAR，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把`MySQL`服务器搞懵，所以这些变长字段占用的存储空间分为两部分：【真正的数据内容】和【占用的字节数】。在`Compact`行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而**形成一个变长字段长度列表**，各变长字段数据占用的字节数按照列的顺序**逆序存放**。

以上面数据为例，`record_format_demo`表的`c1`、`c2`、`c4`列数据长度分别为04，02，01，因此变长字段长度列表为

<img src="assets/image-20240426212740038.png" alt="image-20240426212740038" style="zoom:50%;" />

另外需要说明的是，对于`c3`列的类型是`CHAR(10)`，当我们的`record_format_demo`表采用的是`ascii`字符集（定长字符集）时，c3列的长度不会存储到`变长字段长度列表`中。**如果采用变长的字符集，例如`gbk`（表示一个字符要1～2个字节），`utf8`（表示一个字符要1~3个字节）的话，`c3`列的长度也会被存储到`变长字段长度列表`中**。

#### （2）NULL值列表

MySQL表中的某些列可能存储`NULL`值，如果把这些`NULL`值都放到`记录的真实数据`中存储会很占地方，所以`Compact`行格式把这些值为`NULL`的列统一管理起来，存储到`NULL`值列表中，它的处理过程是这样的。

- 首先统计表中允许存储`NULL`的列有哪些。
- 将每个允许存储`NULL`的列**对应一个二进制位**，二进制位的值为`1`时，代表该列的值为`NULL`，二进制位的值为`0`时，代表该列的值不为`NULL`。 NULL值列表**同样是逆序存放**。

MySQL规定**NULL值列表必须用整数个字节的位表示**，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。所以对于上面两条数据，NULL值列表示意图就是这样：

<img src="assets/image-20240426215347630.png" alt="image-20240426215347630" style="zoom:50%;" />

<img src="assets/image-20240426215023598.png" alt="image-20240426215023598" style="zoom:50%;" />

#### （3）记录头信息

除了`变长字段长度列表`、`NULL值列表`之外，还有一个用于描述记录的`记录头信息`，它是由固定的`5`个字节组成。`5`个字节也就是`40`个二进制位，不同的位代表不同的意思。这些二进制位代表的详细信息如下表，现在不需要了解非常详细，知道就行。

<img src="assets/image-20240427154036594.png" alt="image-20240427154036594" style="zoom:40%;" />

到目前为止，这两条数据长这样

<img src="assets/image-20240427154239882.png" alt="image-20240427154239882" style="zoom:40%;" />

#### （4）记录的真实数据

在MySQL中，除了我们自己定义的列的数据以外，**MySQL会为每个记录默认的添加一些列**，具体的列如下：

| 列名             | 是否必须 | 占用空间 | 描述                   |
| ---------------- | -------- | -------- | ---------------------- |
| `row_id`         | 否       | `6`字节  | 行ID，唯一标识一条记录 |
| `transaction_id` | 是       | `6`字节  | 事务ID                 |
| `roll_pointer`   | 是       | `7`字节  | 回滚指针               |

补充说明一下，InnoDB中，表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则`InnoDB`会为表默认添加一个名为`row_id`的隐藏列作为主键。

所以我们从上表中可以看出：`transaction_id` 和 `roll_pointer` 这两个列是必须的，但是`row_id` 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心，`InnoDB`存储引擎会自己帮我们生成的。

到目前为止，两条数据长这样：

<img src="assets/image-20240427161102979.png" alt="image-20240427161102979" style="zoom:50%;" />

这里需要说明的是：

1. 表`record_format_demo`使用的是`ascii`字符集，所以`0x61616161`就表示字符串`'aaaa'`，`0x626262`就表示字符串`'bbb'`，以此类推。
2. 注意第1条记录中`c3`列的值，它是`CHAR(10)`类型的，它实际存储的字符串是：`'cc'`，而`ascii`字符集中的字节表示是`'0x6363'`，虽然表示这个字符串只占用了2个字节，但整个`c3`列仍然占用了10个字节的空间，**除真实数据以外的8个字节的统统都用空格字符填充，空格字符在`ascii`字符集的表示就是`0x20`**。
3. 注意第2条记录中`c3`和`c4`列的值都为`NULL`，它们被存储在了前边的`NULL值列表`处，在记录的真实数据处就不再冗余存储，从而节省存储空间。

### 3. Redundant行格式

### 4. Dynamic和Compressed行格式

## 三、InnoDB数据页

`MySQL`服务器上负责对表中数据的读取和写入工作的部分是`存储引擎`，服务器支持不同类型的存储引擎，比如`InnoDB`、`MyISAM`、`Memory`，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，**真实数据在不同存储引擎中存放的格式一般是不同的**，甚至有的存储引擎比如`Memory`都不用磁盘来存储数据。

### 1. InnoDB页简介

`InnoDB`是一个**将表中的数据存储到磁盘上**的存储引擎，所以即使关机后重启我们的数据还是存在的。而**真正处理数据的过程是发生在内存中的**，所以**需要把磁盘中的数据加载到内存中**，**如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上**。我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，`InnoDB`存储引擎需要一条一条的把记录从磁盘上读出来么？那样会慢死，`InnoDB`采取的方式是：将数据划分为若干个页，**以页作为磁盘和内存之间交互的基本单位**，InnoDB中页的大小一般16KB。也就是在一般情况下，**一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中**。

### 2. 数据页

`InnoDB`为了不同的目的而设计了许多种不同类型的`页`，比如存放表空间头部信息的页，存放`undo`日志信息的页等等。这些页没有听过没有关系，我们聚焦存放我们表中记录的那种类型的页：`数据页`。数据页代表的这块`16KB`大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示。

<img src="assets/image-20240428221059398.png" alt="image-20240428221059398" style="zoom:30%;" />

| 名称                 | 中文名             | 占用空间大小 | 简单描述                 |
| -------------------- | ------------------ | ------------ | ------------------------ |
| `File Header`        | 文件头部           | `38`字节     | 页的一些通用信息         |
| `Page Header`        | 页面头部           | `56`字节     | 数据页专有的一些信息     |
| `Infimum + Supremum` | 最小记录和最大记录 | `26`字节     | 两个虚拟的行记录         |
| `User Records`       | 用户记录           | 不确定       | 实际存储的行记录内容     |
| `Free Space`         | 空闲空间           | 不确定       | 页中尚未使用的空间       |
| `Page Directory`     | 页面目录           | 不确定       | 页中的某些记录的相对位置 |
| `File Trailer`       | 文件尾部           | `8`字节      | 校验页是否完整           |

#### （1）记录在页中的存储

在页的7个组成部分中，我们自己存储的记录会按照我们指定的`行格式`存储到`User Records`部分。但是在一开始生成页的时候，其实并没有`User Records`这个部分（对应下图第一张图），每当我们插入一条记录，都会从`Free Space`部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到`User Records`部分，当`Free Space`部分的空间全部被`User Records`部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

<img src="assets/image-20240502090707403.png" alt="image-20240502090707403" style="zoom:50%;" />

#### （2）记录头信息

我们先创建一个表

```mysql
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)
```

这个表中记录的行格式示意图如下所示：

<img src="assets/16a95c0feca77be3~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.png" alt="16a95c0feca77be3~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75" style="zoom:70%;" />

`记录头信息`由5个字节组成，再次把这些`记录头信息`中各个属性的大体意思浏览一下：

<img src="assets/image-20240427154036594.png" alt="image-20240427154036594" style="zoom:40%;" />

往数据库里插入4条数据，来观察效果

```mysql
mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
```

插入后，4条数据的头信息长这样

<img src="assets/image-20240502204217130.png" alt="image-20240502204217130" style="zoom:50%;" />

- `delete_mask`：这个属性标记着当前记录是否被删除，占用1个二进制位，值为`0`的时候代表记录并没有被删除，为`1`的时候代表记录被删除掉了。被删除的记录还在`页`中么？是的，这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已。

- `min_rec_mask`：B+树的每层非叶子节点中的最小记录都会添加该标记

- `n_owned`：稍后详细介绍

- `heap_no`：这个属性表示当前记录在本`页`中的位置，从图中可以看出来，我们插入的4条记录在本`页`中的位置分别是：`2`、`3`、`4`、`5`。没有`0`和`1`，这是因为每个页里边儿加了两个记录，一个代表`最小记录`，一个代表`最大记录`。

- `record_type`，这个属性表示当前记录的类型，一共有4种类型的记录，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录。

- `next_record`：它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的`next_record`值为`32`，意味着从第一条记录的真实数据的地址处向后找`32`个字节便是下一条记录的真实数据。`最大记录`的`next_record`的值为`0`，这也就是说最大记录是没有`下一条记录`了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：

  <img src="assets/image-20240502205708322.png" alt="image-20240502205708322" style="zoom:40%;" />

从图中可以看出来，删除第2条记录前后主要发生了这些变化：

- 第2条记录并没有从存储空间中移除，而是把该条记录的`delete_mask`值设置为`1`。
- 第2条记录的`next_record`值变为了0，意味着该记录没有下一条记录了。
- 第1条记录的`next_record`指向了第3条记录。
- `最大记录`的`n_owned`值从`5`变成了`4`，这一点的变化，后面详细说明。

### 3. 页目录

### 4. 页面头部

### 5. 文件头部

## 四、MySQL的数据目录



## 二十、事务

### 1. ACID

#### （1）原子性

现实世界中转账操作是一个不可分割的操作，也就是说要么压根儿就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况，这种规则称之为`原子性`。数据库中的一条操作可能被分解成若干个步骤，比**如先修改缓存页，之后再刷新到磁盘等**，而且任何一个可能的时间都可能发生意想不到的错误，可能是数据库本身的错误，或者是操作系统错误，甚至是直接断电之类的，而使操作执行不下去。为了保证在数据库世界中某些操作的原子性，需要保证如果在执行操作的过程中发生了错误，把已经做了的操作恢复成没执行之前的样子。

这个特性可以说是事务最重要的特性。

#### （2）隔离性

现实世界中的两次状态转换应该是互不影响的，比如说张三向李四同时进行的两次金额为5元的转账（假设可以在两个ATM机上同时操作）。那么最后张三的账户里肯定会少10元，李四的账户里肯定多了10元。但是到对应的数据库世界中，事情又变的复杂了一些。为了简化问题，我们粗略的假设张三向李四转账5元的过程是由下边几个步骤组成的：

- 步骤一：读取张三账户的余额到变量A中，这一步骤简写为`read(A)`。
- 步骤二：将张三账户的余额减去转账金额，这一步骤简写为`A = A - 5`。
- 步骤三：将张三账户修改过的余额写到磁盘里，这一步骤简写为`write(A)`。
- 步骤四：读取李四账户的余额到变量B，这一步骤简写为`read(B)`。
- 步骤五：将李四账户的余额加上转账金额，这一步骤简写为`B = B + 5`。
- 步骤六：将李四账户修改过的余额写到磁盘里，这一步骤简写为`write(B)`。

我们将张三向李四同时进行的两次转账操作分别称为`T1`和`T2`，在现实世界中`T1`和`T2`是应该没有关系的，可以先执行完`T1`，再执行`T2`，或者先执行完`T2`，再执行`T1`，对应的数据库操作就像这样：

<img src="assets/image-20240501153944925.png" alt="image-20240501153944925" style="zoom:50%;" />

但是真实的数据库中`T1`和`T2`的操作可能交替执行，比如这样

<img src="assets/image-20240501154050270.png" alt="image-20240501154050270" style="zoom:50%;" />

如果按照上图中的执行顺序来进行两次转账的话，最终张三的账户里还剩`6`元钱，相当于只扣了5元钱，但是李四的账户里却成了`12`元钱，相当于多了10元钱，这银行岂不是要亏死了？

现实世界中状态转换对应的某些数据库操作来说，不仅要保证这些操作以`原子性`的方式执行完成，而且要保证其它的状态转换不会影响到本次状态转换，这个规则被称之为`隔离性`。这时就需要采取一些措施来让访问相同数据（上例中的A账户和B账户）的不同状态转换（上例中的`T1`和`T2`）对应的数据库操作的执行顺序有一定规律。

#### （3）持久性

比较好理解，`持久性`意味着数据库操作所修改的数据，不论之后发生了什么事故，都应该在磁盘上保留下来，这个规则被称为`持久性`。

#### （4）一致性

一致性比较难理解，参考https://www.zhihu.com/question/31346392/answer/290643186

**AID都是手段，C是目的**，一致性是指：数据库状态与真实业务状态相一致。为了达成一致性，需要在事务中保证原子性、隔离性和持久性。做个比喻事务就好比一个保镖，我们提到事务就会说ACID，而我们提到保镖会说强壮、好功夫、踏实、安全，这里强壮，好功夫和踏实都是保镖自己的特征，而安全则是我们聘请保镖的目的。

数据库本身能为我们保证一部分一致性需求（保证现实世界的约束永远有效）。`MySQL`数据库可以为表建立主键、唯一索引、外键、声明某个列为`NOT NULL`来拒绝`NULL`值的插入。比如说当我们对某个列建立唯一索引时，如果插入某条记录时该列的值重复了，那么`MySQL`就会报错并且拒绝插入。

### 2. 事务的概念

**把需要保证`原子性`、`隔离性`、`一致性`和`持久性`的一个或多个数据库操作称之为一个`事务`**。`事务`是一个抽象的概念，它其实对应着一个或多个数据库操作。数据库执行的不同阶段，把`事务`大致上划分成了这么几个状态：

- 活动的（active）

  事务对应的数据库操作正在执行过程中时，我们就说该事务处在`活动的`状态。

- 部分提交的（partially committed）

  当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在`部分提交的`状态。

- 失败的（failed）

  当事务处在`活动的`或者`部分提交的`状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在`失败的`状态。

- 中止的（aborted）

  如果事务执行了半截而变为`失败的`状态，就需要把已经修改的数据进行撤销，这个撤销的过程称之为`回滚`。当`回滚`操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了`中止的`状态。

- 提交的（committed）

  当一个处在`部分提交的`状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了`提交的`状态。

<img src="assets/image-20240501161133862.png" alt="image-20240501161133862" style="zoom:50%;" />

从图中可以看出，只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。

>事务的英文是transaction，英文直译就是交易，买卖的意思，交易就是买的人付钱，卖的人交货，不能付了钱不交货，交了货不付钱，所以交易本身就是一种不可分割的操作。国内把transaction翻译成了事务，其实并不准确。

### 3. 事务的语法

**`事务`的本质其实只是一系列数据库操作，只不过这些数据库操作符合`ACID`特性而已**，那么`MySQL`中如何将某些操作放到一个事务里去执行呢？

#### （1）开启事务

可以使用下边两种语句之一来开启一个事务：

- `BEGIN [WORK];`

  `BEGIN`语句代表开启一个事务，后边的单词`WORK`可有可无。开启事务后，就可以继续写若干条语句，这些语句都属于刚刚开启的这个事务。

- `START TRANSACTION;`

  `START TRANSACTION`语句和`BEGIN`语句有着相同的功效，都标志着开启一个事务，不过比`BEGIN`语句牛逼一点儿的是，可以在`START TRANSACTION`语句后边跟随几个`修饰符`，例如`READ ONLY`

#### （2）提交事务

开启事务之后就可以继续写需要放到该事务中的语句了，当最后一条语句写完了之后，我们就可以提交该事务了，提交的语句也很简单：`COMMIT [WORK]`。下面是一个完整的开启提交事务的例子

```mysql
mysql> BEGIN;
Query OK, 0 rows affected (0.00 sec)

mysql> UPDATE account SET balance = balance - 10 WHERE id = 1;
Query OK, 1 row affected (0.02 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> UPDATE account SET balance = balance + 10 WHERE id = 2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> COMMIT;
Query OK, 0 rows affected (0.00 sec)
```

#### （3）手动中止事务

如果我们写了几条语句之后发现上边的某条语句写错了，我们可以手动的使用下边这个语句来将数据库恢复到事务执行之前的样子：`ROLLBACK [WORK]`

```mysql
mysql> BEGIN;
Query OK, 0 rows affected (0.00 sec)

mysql> UPDATE account SET balance = balance - 10 WHERE id = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> UPDATE account SET balance = balance + 1 WHERE id = 2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> ROLLBACK;
Query OK, 0 rows affected (0.00 sec)
```

#### （4）自动提交

`MySQL`中有一个系统变量`autocommit`：

```bash
mysql> SHOW VARIABLES LIKE 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.01 sec)
```

可以看到它的默认值为`ON`，也就是说默认情况下，如果我们不显式的使用`START TRANSACTION`或者`BEGIN`语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的`自动提交`。假如我们在张三向李四转账10元时不以`START TRANSACTION`或者`BEGIN`语句显式的开启一个事务，那么下边这两条语句就相当于放到两个独立的事务中去执行：

```mysql
UPDATE account SET balance = balance - 10 WHERE id = 1;
UPDATE account SET balance = balance + 10 WHERE id = 2;
```

> 这里有个之前一直没有搞懂的问题，既然DDL语句会自动提交事务，我们在平时的业务中还需要去显式的开启事务吗？我的答案是，**如果只是一个单独的语句，我们没必要去开启事务。但是对于一个类似于银行转账的事务，显然我们需要去开启一个事务**，因为如果只转出成功而没有转入成功，显然对转账方是不公平的。

如果想关闭这种`自动提交`的功能，可以使用下边两种方法之一：

- 显式的的使用`START TRANSACTION`或者`BEGIN`语句开启一个事务。
- 把系统变量`autocommit`的值设置为`OFF`

```mysql
SET autocommit = OFF;
```

#### （5）隐式提交

当我们使用`START TRANSACTION`或者`BEGIN`语句开启了一个事务，或者把系统变量`autocommit`的值设置为`OFF`时，事务就不会进行`自动提交`，但是**如果我们输入了某些语句之后就会`悄悄的`提交掉，就像我们输入了`COMMIT`语句了一样**，这种因为某些特殊的语句而导致事务提交的情况称为`隐式提交`，这些会导致事务隐式提交的语句包括：

- 定义或修改数据库对象的数据定义语言（Data definition language，缩写为：`DDL`）。

所谓的数据库对象，指的就是`数据库`、`表`、`视图`、`存储过程`等等这些东西。当我们使用`CREATE`、`ALTER`、`DROP`等语句去修改这些所谓的数据库对象时，就会隐式的提交前边语句所属于的事务，就像这样：

> ⚠️注意看这个例子

```mysql
BEGIN;

SELECT ... # 事务中的一条语句
UPDATE ... # 事务中的一条语句
... # 事务中的其它语句

CREATE TABLE ... # 此语句会隐式的提交前边语句所属于的事务
```

- 当我们使用`ALTER USER`、`CREATE USER`、`DROP USER`、`GRANT`、`RENAME USER`、`REVOKE`、`SET PASSWORD`等语句时也会隐式的提交前边语句所属于的事务。

## 二十一、事务的隔离级别和MVCC

### 1. 事务隔离级别

`MySQL`是一个客户端／服务器架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，**每个客户端与服务器连接上之后，就可以称之为一个会话（`Session`）**。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。前面说过事务有一个称之为`隔离性`的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样子的话对性能影响太大，我们既想保持事务的`隔离性`，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，鱼和熊掌不可得兼，舍一部分`隔离性`而取性能者也。

### 2. 并发事务遇到的问题

我们先看一下访问相同数据的事务在不保证串行执行（也就是执行完一个再执行另一个）的情况下可能会出现哪些问题：

#### （1）脏写

**一个事务修改了另一个未提交事务修改过的数据。**

<img src="assets/image-20240501195425493.png" alt="image-20240501195425493" style="zoom:50%;" />

> 注意：由于脏写这个问题太严重了，现在MySQL不论是哪种隔离级别，都不允许脏写的情况发生，因此我们会发现按照作者这个操作，在执行第4个操作时会卡住。

如上图，`Session A`和`Session B`各开启了一个事务，`Session B`中的事务先将`number`列为`1`的记录的`name`列更新为`'关羽'`，然后`Session A`中的事务接着又把这条`number`列为`1`的记录的`name`列更新为`张飞`。如果之后`Session B`中的事务进行了回滚，那么`Session A`中的更新也将不复存在，这种现象就称之为`脏写`。这时`Session A`中的事务就很懵逼，我明明把数据更新了，最后也提交事务了，怎么到最后说自己啥也没干呢

#### （2）脏读

**一个事务读到了另一个未提交事务修改过的数据。**

> 先设置隔离级别为【未提交读】，SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

<img src="assets/image-20240501195750527.png" alt="image-20240501195750527" style="zoom:50%;" />

如上图，`Session A`和`Session B`各开启了一个事务，`Session B`中的事务先将`number`列为`1`的记录的`name`列更新为`'关羽'`，然后`Session A`中的事务再去查询这条`number`为`1`的记录，如果读到列`name`的值为`'关羽'`，而`Session B`中的事务稍后进行了回滚，那么`Session A`中的事务相当于读到了一个不存在的数据，这种现象就称之为`脏读`。

#### （3）不可重复读

如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。

> 先设置隔离级别为【已提交读】，SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;

<img src="assets/image-20240502083839602.png" alt="image-20240502083839602" style="zoom:50%;" />

如上图，我们在`Session B`中提交了几个隐式事务（注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了`number`列为`1`的记录的列`name`的值，每次事务提交之后，如果`Session A`中的事务都可以查看到最新的值，这种现象也被称之为`不可重复读`。

> 理论上来说，开启了一个事务，相当于躲在防空洞里，外面世界如何变化，和我无关

#### （4）幻读

如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。

> 先设置隔离级别为【可重复读】，SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;

<img src="assets/image-20240502084501212.png" alt="image-20240502084501212" style="zoom:50%;" />

如上图，`Session A`中的事务先根据条件`number > 0`这个条件查询表`hero`，得到了`name`列值为`'刘备'`的记录；之后`Session B`中提交了一个隐式事务，该事务向表`hero`中插入了一条新记录；之后`Session A`中的事务再根据相同的条件`number > 0`查询表`hero`，得到的结果集中包含`Session B`中的事务新插入的那条记录，这种现象也被称之为`幻读`。

> 注意⚠️：MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的，也就是这个例子并不能复现出来。

### 3. 事务中的隔离级别

#### （1）隔离级别语法

查看事务隔离级别： 

```mysql
SHOW VARIABLES LIKE 'transaction_isolation';
```

设置事务隔离级别：

```mysql
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;
```

#### （2）四种隔离级别

- `READ UNCOMMITTED`：未提交读。
- `READ COMMITTED`：已提交读。
- `REPEATABLE READ`：可重复读。MySQL默认的隔离级别。
- `SERIALIZABLE`：可串行化。

<img src="assets/image-20240501210551135.png" alt="image-20240501210551135" style="zoom:50%;" />

给这些问题按照严重性来排一下序：**脏写 > 脏读 > 不可重复读 > 幻读**。上边所说的舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生。

### 4. MVCC

## 二十五、锁

### 1. 并发事务的问题

并发事务访问相同记录的情况大致可以划分为3种（读-写和写-读）是同一种：

#### （1）读-读

即并发事务相继读取相同的记录，读取操作本身不会对记录有一毛钱影响，并不会引起什么问题，所以允许这种情况的发生。

#### （2）写-写

前边说过，在这种情况下会发生`脏写`的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过`锁`来实现的。

这个所谓的`锁`其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有`锁结构`和记录进行关联的，当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的`锁结构`，当没有的时候就会在内存中生成一个`锁结构`与之关联。比方说事务`T1`要对这条记录做改动，就需要生成一个`锁结构`与之关联。

<img src="assets/image-20240502153917080.png" alt="image-20240502153917080" style="zoom:50%;" />



在`锁结构`里有很多信息，为了简化理解，我们现在只把两个比较重要的属性拿了出来：

- `trx信息`：代表这个锁结构是哪个事务生成的。
- `is_waiting`：代表当前事务是否在等待。

当事务`T1`改动了这条记录后，就生成了一个`锁结构`与该记录关联，之前没有别的事务为这条记录加锁，所以`is_waiting`属性就是`false`，这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操作了。

在事务`T1`提交之前，另一个事务`T2`也想对该记录做改动，那么先去看看有没有`锁结构`与这条记录关联，发现有一个`锁结构`与之关联后，然后也生成了一个`锁结构`与这条记录关联，不过`锁结构`的`is_waiting`属性值为`true`，表示当前事务需要等待，我们把这个场景就称之为获取锁失败，或者加锁失败，或者没有成功的获取到锁，画个图表示就是这样。

<img src="assets/image-20240502154152632.png" alt="image-20240502154152632" style="zoom:50%;" />

在事务`T1`提交之后，就会把该事务生成的`锁结构`释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务`T2`还在等待获取锁，所以把事务`T2`对应的锁结构的`is_waiting`属性设置为`false`，然后把该事务对应的线程唤醒，让它继续执行，此时事务`T2`就算获取到锁了。效果图就是这样：

<img src="assets/image-20240502154645391.png" alt="image-20240502154645391" style="zoom:50%;" />

#### （3）读-写

也就是一个事务进行读取操作，另一个进行改动操作。前边说过，这种情况下可能发生`脏读`、`不可重复读`、`幻读`的问题。



